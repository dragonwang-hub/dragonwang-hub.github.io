<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前后端分离部署应用的SSO配置实践</title>
      <link href="2024/05/21/qian-hou-duan-fen-chi-bu-shu-ying-yong-de-oauth2-oidc-pei-zhi-shi-jian/"/>
      <url>2024/05/21/qian-hou-duan-fen-chi-bu-shu-ying-yong-de-oauth2-oidc-pei-zhi-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="前后端分离部署应用的SSO配置实践"><a href="#前后端分离部署应用的SSO配置实践" class="headerlink" title="前后端分离部署应用的SSO配置实践"></a>前后端分离部署应用的SSO配置实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>谈到SSO，我们第一念头也许是Single Sign On，单点登录。也许会映射到具体产品，比如Azure AD配置，或Github配置，或VX配置相关。SSO是一种思想概念，具体实现又有不同方式，比如CAS，OAUTH2/OIDC。</p><p>在项目实践中，我们常常能听到OAuth2或者OIDC，以及基于此协议实现的一些框架lib。说到这里，既然有框架，基于框架必然有已实现的案例，则实现必不会过于复杂。实际也确实如此，在微服务架构中，大多数登录服务会在业务服务上游，因此可以将OAuth2框架集成在登录服务中，在登录成功后再将流量路由到下游具体业务服务。亦或是单体架构，也可如此集成实现。</p><p>但在前后端分离部署应用中，在引用OAuth2框架后，仍需要将前后端处理流程统一起来。但在前后端使用不同语言并部署在不同的Container或VM时，就需要对后端引入的OAuth2框架的默认流程进行部分修改处理。本文对此类应用模式的OAuth2集成实践进行梳理记录，提供相应的解决方案。</p><h2 id="OAUTH2-OIDC"><a href="#OAUTH2-OIDC" class="headerlink" title="OAUTH2 / OIDC"></a>OAUTH2 / OIDC</h2><p>OAuth, 通常是指OAuth 2.0协议，它是一种Authorization协议并不是一种Authentication协议，虽然OAuth 2的流程中只描述了Authorization。但是在实际使用中，Authorization脱离Authentication并没有任何意义。因此，有时提到OAuth2，必然也会提到OIDC。OIDC全称OpenID Connect，是基于OAuth2.0扩展出来的一个协议。除了能够OAuth2.0中的Authorization场景，还额外定义了Authentication的场景，其可以理解为基于OAuth2的再扩展。</p><p>笔者此处将根据Browser/Server架构阐述OAuth2及OIDC的具体的某一种实现流程，希望能使读者对此有更清晰的理解。<br>注：以下均为授权码流程 </p><h3 id="OAuth2在B-S架构中流程"><a href="#OAuth2在B-S架构中流程" class="headerlink" title="OAuth2在B/S架构中流程"></a>OAuth2在B/S架构中流程</h3><p>1、SSO事件触发，浏览器重定向到SSO Server进行认证登录<br>2、在已登录状态下或登录成功后，SSO Server将重定向（浏览器）至预设定的Redirect_Uri上，并在URL中返回重要参数信息Authorization Code（授权码）<br>3、浏览器将获取的所有参数信息（包括授权码等）发送至后端Server<br>4、后端Server将获取的信息校验后结合后端定义的Client Id和Client Secret信息，与SSO Server进行交互，以保证请求的正确性和安全性<br>5、请求成功，SSO Server将返回access-token等数据至后端Server<br>6、后端根据access-token再次与SSO Server交互以获取当前用户信息<br>7、根据获取的用户信息在后端Server构造认证凭证并返回前端（浏览器）   </p><h3 id="OIDC在B-S架构中流程"><a href="#OIDC在B-S架构中流程" class="headerlink" title="OIDC在B/S架构中流程"></a>OIDC在B/S架构中流程</h3><p>1、SSO事件触发，浏览器重定向到SSO Server进行认证登录。<strong>重定向链接的scope参数需包含openid，以此标识为OIDC流程</strong><br>2、在已登录状态下或登录成功后，SSO Server将重定向（浏览器）至预设定的Redirect_Uri上，并在URL中返回重要参数信息Authorization Code（授权码）<br>3、浏览器将获取的所有参数信息（包括授权码等）发送至后端Server<br>4、后端Server将获取的信息校验后结合后端定义的Client Id和Client Secret信息，与SSO Server进行交互，以保证请求的正确性和安全性<br>5、请求成功，SSO Server将返回access-token和<strong>id-token</strong>等数据至后端Server<br>6、校验id-token后获取其中的用户信息，并在后端Server构造认证凭证并返回前端（浏览器） </p><!-- 两个流程图 --><img src="/2024/05/21/qian-hou-duan-fen-chi-bu-shu-ying-yong-de-oauth2-oidc-pei-zhi-shi-jian/SSO-Flow.png" class="" alt="OAuth2 &#x2F; OIDC Flow"><p>根据以上对比，可发现两种协议实现思路的区别，但无论方式如何，最终目的仍是从SSO Server获取当前登录用户信息以适应当前系统服务。<br>此处，笔者强调一个较为细节的区别点，在OIDC的第1步，重定向链接中会多一个参数为nonce，此参数将会在第5步作为id-token的claims的一对key/value进行返回。其主要作用在于减缓重放攻击。</p><p>此处笔者将OAuth2授权码模式流程以较为详细的方式进行梳理阐述。关于协议及其他模式，读者可查看自行搜索查看详细信息。 </p><h2 id="Spring-Security-OAuth2-Client-核心流程"><a href="#Spring-Security-OAuth2-Client-核心流程" class="headerlink" title="Spring Security OAuth2 Client 核心流程"></a>Spring Security OAuth2 Client 核心流程</h2><p>在Spring框架的后端服务中，提到认证和授权，大部分情况都会涉及Spring Security，那么在涉及OAuth2时便必然需要Spring Security OAuth2相关的依赖。此节将对此框架中核心的Filter进行简短解析，以熟悉整套OAuth2/OIDC流程的具体实现方式。</p><ul><li>OAuth2AuthorizationRequestRedirectFilter: 实现重定向至SSO Server获取auth code</li><li>OAuth2LoginAuthenticationFilter: 拦截预配置的Redirect Uri，根据auth code等信息与SSO Server就交互认证获取UserInfo</li><li>OidcAuthorizationCodeAuthenticationProvider：提供依据Oidc协议的具体认证方法<!-- - OAuth2LoginAuthenticationProvider：提供依据OAuth2协议的具体认证方法 --></li></ul><p>源码分析：</p><ol><li><code>OAuth2AuthorizationRequestRedirectFilter.doFilterInternal</code><br>根据OAuth2 Client配置信息，包括Client Id/Secret, Redirect Uri等构造重定向URL并进行重定向以获取auth code。同时，将配置信息以<code>OAuth2AuthorizationRequest</code>对象保存，用于后续校验。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doFilterInternal</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span><span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 根据OAuth2 Client配置信息构造 OAuth2AuthorizationRequest</span>    <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestResolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>authorizationRequest <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 重定向至SSO Server</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sendRedirectForAuthorization</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> authorizationRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var11<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsuccessfulRedirectForAuthorization</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> var11<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sendRedirectForAuthorization</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponseresponse</span><span class="token punctuation">,</span> <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 授权码模式，保存OAuth2AuthorizationRequest，重定向</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">AuthorizationGrantType</span><span class="token punctuation">.</span>AUTHORIZATION_CODE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">.</span><span class="token function">getGrantType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestRepository<span class="token punctuation">.</span><span class="token function">saveAuthorizationRequest</span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRedirectStrategy<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> authorizationRequest<span class="token punctuation">.</span><span class="token function">getAuthorizationRequestUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// OAuth2AuthorizationRequest对象信息用于保证SSO登录过程的安全性，其中包含clientId，redirectUri，scope，state，nonce等信息。关于这些字段具体含义，可查看Oidc协议或相关文档。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当在SSO Server登录后，SSO Server会根据配置的Redirect Uri重定向回SSO client服务。<br>2. <code>OAuth2LoginAuthenticationFilter.attemptAuthentication</code></p><p>根据重定向回来的Uri参数，获取auth code，并根据当前的client配置与SSO Serve进行认证，校验，成功后返回认证结果Authentication对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Authentication</span> <span class="token function">attemptAuthentication</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">OAuth2AuthorizationResponseUtils</span><span class="token punctuation">.</span><span class="token function">isAuthorizationResponse</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// url中获取正确auth code后的处理流程</span>        <span class="token comment">// 获取第1步重定向至SSO Server的请求信息 (OAuth2AuthorizationRequestRedirectFilter中完成的存储动作)</span>      <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestRepository<span class="token punctuation">.</span><span class="token function">removeAuthorizationRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>authorizationRequest <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2AuthenticationException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 确保服务已配置此SSO Server的信息</span>        <span class="token class-name">String</span> registrationId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>authorizationRequest<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"registration_id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ClientRegistration</span> clientRegistration <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientRegistrationRepository<span class="token punctuation">.</span><span class="token function">findByRegistrationId</span><span class="token punctuation">(</span>registrationId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clientRegistration <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2AuthenticationException</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment">// 构造包含client相关信息的对象</span>          <span class="token class-name">OAuth2LoginAuthenticationToken</span> authenticationRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2LoginAuthenticationToken</span><span class="token punctuation">(</span>clientRegistration<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2AuthorizationExchange</span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">,</span> authorizationResponse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//  [*重*] 调用对应的 AuthenticationProvider 进行对应的认证流程</span>          <span class="token class-name">OAuth2LoginAuthenticationToken</span> authenticationResult <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OAuth2LoginAuthenticationToken</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAuthenticationManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span>authenticationRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">OAuth2AuthenticationToken</span> oauth2Authentication <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OAuth2AuthenticationToken</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>authenticationResultConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>authenticationResult<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>oauth2Authentication<span class="token punctuation">,</span> <span class="token string">"authentication result cannot be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token keyword">return</span> oauth2Authentication<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在AuthenticationFilter中，只要可以返回正常的Authentication对象，则说明认证成功，SpringSecurity会将Authentication存入的ecurityContext中，并执行successfulHandler进行认证成功后处理。  </p><p>在此Filter中，比较重要的是调用对应的AuthenticationProvider进行认证流程，以下将对OIDC流程的具体认证方法简单分析。<br>注：若使用OIDC认证流程，则在第1步重定向的URL中的scope参数中需存在openid参数。</p><ol start="3"><li><code>OidcAuthorizationCodeAuthenticationProvider.authenticate</code><br>在Spring Security中存在很多的AuthenticationProvider的子类，都是对不同的认证方式的具体认证逻辑的实现。在认证成功后会返回Authentication对象，此处分析的是OIDC流程中AuthenticationProvider<br>涉及了与SSO Server的交互获取access-token，id-token等信息，以及token校验和构造认证的Authentication。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Authentication</span> <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token class-name">Authentication</span> authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// oidc流程</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getAuthorizationExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthorizationRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getScopes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"openid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequest <span class="token operator">=</span> authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getAuthorizationExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthorizationRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">OAuth2AuthorizationResponse</span> authorizationResponse <span class="token operator">=</span> authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getAuthorizationExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthorizationResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 校验</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// fetch access-token等信息，应包括id-token</span>      <span class="token class-name">OAuth2AccessTokenResponse</span> accessTokenResponse <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span>authorizationCodeAuthentication<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ClientRegistration</span> clientRegistration <span class="token operator">=</span> authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getClientRegistration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> additionalParameters <span class="token operator">=</span> accessTokenResponse<span class="token punctuation">.</span><span class="token function">getAdditionalParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// id-token 存于此</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>additionalParameters<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"id_token"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2AuthenticationException</span><span class="token punctuation">(</span>invalidIdTokenError<span class="token punctuation">,</span> invalidIdTokenError<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 解析id-token，构造id-token对象</span>        <span class="token class-name">OidcIdToken</span> idToken <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createOidcToken</span><span class="token punctuation">(</span>clientRegistration<span class="token punctuation">,</span> accessTokenResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 校验id-token中claims的nonce属性是否与第1步重定向URL中的nonce参数值匹配</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">validateNonce</span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">,</span> idToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 校验通过后，构造User对象，此时，与SSO Server认证成功，进入后处理</span>        <span class="token class-name">OidcUser</span> oidcUser <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OidcUser</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">loadUser</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OidcUserRequest</span><span class="token punctuation">(</span>clientRegistration<span class="token punctuation">,</span> accessTokenResponse<span class="token punctuation">.</span><span class="token function">getAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> idToken<span class="token punctuation">,</span> additionalParameters<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment">// 交互信息汇总，返回上层</span>        <span class="token class-name">OAuth2LoginAuthenticationToken</span> authenticationResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OAuth2LoginAuthenticationToken</span><span class="token punctuation">(</span>authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getClientRegistration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authorizationCodeAuthentication<span class="token punctuation">.</span><span class="token function">getAuthorizationExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> oidcUser<span class="token punctuation">,</span> mappedAuthorities<span class="token punctuation">,</span> accessTokenResponse<span class="token punctuation">.</span><span class="token function">getAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> accessTokenResponse<span class="token punctuation">.</span><span class="token function">getRefreshToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> authenticationResult<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>至于OAuth2的认证方法，可查看<code>OAuth2LoginAuthenticationProvider</code>。  </li></ol><p>如果你读到这里，也便能发现Spring Security OAuth2 Client已实现了全套OAuth2/OIDC登录流程，只需要进行基础配置即可实现全套功能。  </p><!-- 框架实现了整套流程，单体部署的应用可直接使用默认机制，但对于 --><h2 id="前后端分离部署集成SSO实践"><a href="#前后端分离部署集成SSO实践" class="headerlink" title="前后端分离部署集成SSO实践"></a>前后端分离部署集成SSO实践</h2><p>对于前后端分离部署的应用，前端页面资源和后端接口资源分别处于不同的服务器地址，而后端服务器通常会处于受保护的网络。此时SSO配置的Redirect Uri的BaseUrl为前端服务器地址。<br>应对这种需求，通常存在多种解决方案，其中一种是通过前端应用发起授权请求并处理重定向的操作，后端服务完成其他操作。<br><br>具体前后端职责划分如下：<br><br>1、前端应用将用户重定向至SSO Server进行授权登录。并处理登录后重定向回来的URL的参数信息，包括授权码等，发送至后端服务。<br><br>2、后端服务接收到授权码后与SSO Server交互获取用户信息并构造认证凭证完成登录流程。<br></p><!-- 当然，此处可在后端自定义处理逻辑来实现交互流程。 --><p>在上节，笔者已阐述SpringSecurityOAuth2Client的基本处理逻辑，如何配置SpringSecurityOAuth2Client框架来适应这种情况呢？<br><br>此节将以Azure AD作为SSO Server，结合SpringSecurity框架，给出前后端分离部署集成SSO(OIDC)的实践示例。<br><br>给出具体分析之前，再次分析Security框架提供的默认机制。</p><ul><li>因重定向至SSO Server授权页面操作不再由后端发起，不需要触发<code>OAuth2AuthorizationRequestRedirectFilter</code>流程，但仍需要构造<code>OAuth2AuthorizationRequest</code>并保存以在<code>OAuth2LoginAuthenticationFilter</code>中的认证过程中进行信息提取和校验。</li><li><code>OAuth2AuthorizationRequest</code>中的<em>state</em>和<em>nonce</em>参数应由前端应用提供，以保证校验过程的正确性。</li></ul><p>注：以下仅展示核心代码。</p><ol><li>前端应用触发后重定向至授权登录页面<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// first: gen &amp; save nonce</span><span class="token comment">// then:</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://login.microsoftonline.com/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>tenantId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">/oauth2/v2.0/authorize?client_id=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>clientId<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">&amp;response_type=code&amp;redirect_uri=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>redirectUri<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">&amp;response_mode=query&amp;scope=offline_access%20profile%20openid&amp;state=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>state<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">&amp;nonce=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>nonce<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span><span class="token comment">// 注：此处URL中nonce的值应为hash后的值，save的nonce应为初始值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>tenantId, clientId, redirectUri为SSO Server端已配置的信息。</li><li>state, nonce 在前端应用生成的随机字符串。</li></ul><ol start="2"><li>前端应用解析SSO Server授权登录后的授权码等信息，并发送至后端<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// first: get nonce</span><span class="token comment">// then:</span><span class="token keyword">const</span> searchParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> authCode <span class="token operator">=</span> searchParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'code'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>authCode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/login/oauth2/code/azure'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    params<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span>searchParams<span class="token punctuation">,</span>        nonce<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>SpringSecurityOAuth2Client框架获取auth code进行后续处理的默认API path为**/login/oauth2/code/{registerId}**，若无特殊处理，可直接请求此接口触发后续流程。</li><li>后端服务自定义过滤器构造<code>OAuth2AuthorizationRequest</code><br>自定义的Filter依据<code>OAuth2AuthorizationRequestRedirectFilter</code>实现，核心区别在于，自定义Filter只保存<code>OAuth2AuthorizationRequest</code>对象，不进行Redirect操作。<br>此处也将前端应用第1步重定向用的参数保存更新至<code>OAuth2AuthorizationRequest</code>对象。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizationRequestSaveFilter</span> <span class="token keyword">extends</span> <span class="token class-name">OncePerRequestFilter</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 在指定请求中执行操作</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> AUTHORIZATION_REQUEST_URI <span class="token operator">=</span> <span class="token string">"/login/oauth2/code"</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">OAuth2AuthorizationRequestResolver</span> authorizationRequestResolver<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">AuthorizationRequestRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OAuth2AuthorizationRequest</span><span class="token punctuation">></span></span> authorizationRequestRepository<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">AuthorizationRequestSaveFilter</span><span class="token punctuation">(</span><span class="token class-name">ClientRegistrationRepository</span> clientRegistrationRepository<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestRepository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpSessionOAuth2AuthorizationRequestRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultOAuth2AuthorizationRequestResolver</span><span class="token punctuation">(</span>clientRegistrationRepository<span class="token punctuation">,</span> AUTHORIZATION_REQUEST_URI<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doFilterInternal</span><span class="token punctuation">(</span>      <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>AUTHORIZATION_REQUEST_URI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> state <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"state"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> nonce <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"nonce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestResolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> currentAttributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        currentAttributes<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"nonce"</span><span class="token punctuation">,</span> nonce<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 对框架默认流程构造出的OAuth2AuthorizationRequest的部分参数 替换为 前端传递的真实使用的值 （state, nonce）</span>        <span class="token class-name">OAuth2AuthorizationRequest</span> authorizationRequestWithFE <span class="token operator">=</span>            <span class="token class-name">OAuth2AuthorizationRequest</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>authorizationRequest<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">attributes</span><span class="token punctuation">(</span>currentAttributes<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 保存 OAuth2AuthorizationRequest </span>        <span class="token keyword">this</span><span class="token punctuation">.</span>authorizationRequestRepository<span class="token punctuation">.</span><span class="token function">saveAuthorizationRequest</span><span class="token punctuation">(</span>authorizationRequestWithFE<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// handle exception</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>注：state, nonce值会在后续流程进行匹配校验。这两值的作用可增强安全性，具体信息可查看参考介绍。<br>下一步，此请求将进入<code>OAuth2LoginAuthenticationFilter</code>开启后续的操作，即获取id-token，构造User对象，完成认证流程。<br>通常而言，在认证完成后，会采用自定义的successfulHandler进行认证后处理操作，比如生成Jwt-token返回前端等。此处不再阐述。</li></ol><p>当然，还有一些配置工作，比如将自定义的Filter加入SecurityFilterChain，以及SSO Client的基础信息配置。以下给出示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">public</span> <span class="token class-name">SecurityFilterChain</span> <span class="token function">securityFilterChain</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> http<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>  http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span>          <span class="token punctuation">(</span>authorize<span class="token punctuation">)</span> <span class="token operator">-></span>              authorize                  <span class="token punctuation">.</span><span class="token function">requestMatchers</span><span class="token punctuation">(</span><span class="token string">"/login/oauth2/code/**"</span><span class="token punctuation">)</span>                  <span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token punctuation">.</span><span class="token function">requestMatchers</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span>                  <span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  http<span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">AadWebApplicationHttpSecurityConfigurer</span><span class="token punctuation">.</span><span class="token function">aadWebApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Customizer</span><span class="token punctuation">.</span><span class="token function">withDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 集成 Auzre AD lib的默认配置</span>      <span class="token punctuation">.</span><span class="token function">oauth2Login</span><span class="token punctuation">(</span>oauth <span class="token operator">-></span> oauth<span class="token punctuation">.</span><span class="token function">successHandler</span><span class="token punctuation">(</span>customizedSuccessHandler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 开启oauth2 login， 并添加自定义successHandler</span>      <span class="token punctuation">.</span><span class="token function">addFilterBefore</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AuthorizationRequestSaveFilter</span><span class="token punctuation">(</span>clientRegistrationRepository<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">OAuth2AuthorizationRequestRedirectFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自定义Filter加入FilterChain</span>  <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，我们通过编写部分代码，集成SpringSecurityOAuth2Client，实现了SSO登录。</p><p>在笔者记录此实践过程时，也探索了其他的实现方式，或简单或复杂，若读者有较好实践思路，也可进行实现。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>SSO登录常见功能需求。OIDC/OAUTH2是基于此的协议。基于此协议的实现框架有很多。</p><p>本文基于对Spring Security和OAuth2 Client框架的认知，结合具体实践场景前后端分离部署的应用，给出了一种实践方案，或许不足，但确实可行。<br>希望读者看到此处后，能对OIDC/OAUTH2的流程和OAuth2 Client框架有更清晰的理解。</p><p>笔者仅以此文记录实际情况的实践方式，经验浅薄，若有不足，还请指正。</p><p>参考：<br><br>OAUTH2：<a href="https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow">https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow</a><br>OIDC：<a href="https://learn.microsoft.com/en-us/entra/identity-platform/v2-protocols-oidc">https://learn.microsoft.com/en-us/entra/identity-platform/v2-protocols-oidc</a><br>以下为引用的一段关于nonce的描述：</p><blockquote><p>A value generated and <strong>sent by your app in its request</strong> for an ID token.<br>The same nonce value is included in the ID token returned to your app by the Microsoft identity platform.<br>To <strong>mitigate token replay attacks</strong>, your app should verify the nonce value in the ID token is the same value it sent when requesting the token.<br>The value is typically a unique, random string.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAUTH2 </tag>
            
            <tag> OIDC </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 分离部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ChatGPT学AWS答疑记录</title>
      <link href="2023/05/12/yu-chatgpt-xue-aws-da-yi-ji-lu/"/>
      <url>2023/05/12/yu-chatgpt-xue-aws-da-yi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="跟着ChatGPT学AWS"><a href="#跟着ChatGPT学AWS" class="headerlink" title="跟着ChatGPT学AWS"></a>跟着ChatGPT学AWS</h1><ol><li><p>Cloud computing优势中的Trade capital expense (CAPEX) for operational expense (OPEX)含义？</p><blockquote><p>“Trade capital expense (CAPEX) for operational expense (OPEX)” 这句话是云计算的一个优势点，意思是将企业的资本支出转换为运营支出。在传统的IT环境中，企业需要在购买硬件、设备和设施等方面进行大量的资本支出，这些支出在购买后不能立即转换为收益，需要在未来的几年逐渐摊销。而在云计算中，企业不再需要购买和维护自己的硬件设施，只需要按需租用云服务商提供的资源和服务，并根据实际使用情况支付相应的费用，这种支出是运营支出，能够更好地适应企业的业务变化和需求变化。这样做可以让企业更灵活地控制成本，避免了因大量资本支出而导致的财务压力和资金流失。</p></blockquote></li><li><p>IAM中，一个User A，属于Group A和Group B，如果Group A对S3具有只读权限，而Group B是所有权限。那么User A对S3的操作权限是？  </p><blockquote><p>用户的最终权限是组权限与用户权限的并集。在这个情况下，User A 的操作权限应该是具有 Group A 和 Group B 所有权限，因为 Group B 包含了 Group A 的权限，所以 User A 具有 S3 的所有权限，包括只读和读写。</p></blockquote></li><li><p>IAM role 创建就是用于被Assume的吗？(Assume: 其他用户以扮演此Role的形式访问AWS)</p><blockquote><p>IAM Role 的主要目的是被其他实体 “assume”（扮演）以获取临时安全凭证并访问 AWS 资源。下面是四个场景的答案：<br>a. 跨账户访问：在这种场景下，IAM Role 被其他 AWS 账户中的用户或服务 “assume”，以获取临时凭证并访问资源。这种跨账户访问可以实现安全的资源共享和管理。<br>b. 临时访问凭证：IAM Role 可以用于为临时用户或服务生成临时访问凭证。这些凭证具有一定的时效性，可以用于授予临时访问权限，而无需直接使用长期凭证（如密钥或密码）。<br>c. 第三方身份提供商（IdP）集成：IAM Role 可以与第三方身份提供商（如 SSO 平台）集成。在这种集成中，IAM Role 与身份提供商建立信任关系，允许用户使用其在身份提供商上的凭据进行身份验证，并获取与 IAM Role 关联的权限。<br>d. AWS服务(比如EC2)访问：某些 AWS 服务可以扮演 IAM 角色以访问其他服务或资源，以便完成特定任务。</p></blockquote></li><li><p>IAM Role create account中的Web identity 与 SAML 2.0选项区别</p><blockquote><p>Web Identity: Web Identity 是一种通过第三方身份提供商（如 Google、Facebook、Amazon、Microsoft 等）进行身份验证的机制。用户使用他们在第三方身份提供商上的凭证进行身份验证，然后获取对 AWS 资源的临时访问权限。这种机制常用于让用户通过他们已有的社交媒体或云服务提供商的凭证来访问 AWS 资源，从而简化身份验证和授权管理。<br>SAML 2.0: Security Assertion Markup Language (SAML) 是一种基于 XML 的开放标准，用于在不同的身份提供者和服务提供者之间进行身份验证和授权。SAML 2.0 允许用户使用他们在身份提供者上的凭证进行身份验证，并通过 SAML 断言将身份信息传递给服务提供者。这种机制通常用于企业环境中，用于实现单点登录 (Single Sign-On, SSO) 和跨域身份验证。<br>虽然 Web Identity 和 SAML 2.0 都涉及身份验证和授权，但它们的实现方式和使用场景有所不同。Web Identity 更适用于与第三方身份提供商集成，让用户使用他们已有的凭证来访问 AWS 资源。SAML 2.0 则更适用于企业环境，实现不同系统之间的身份验证和授权集成。</p></blockquote></li><li><p>通过aws budget setup可以保证费用不会超过预算吗？还是只是一个报警通知呢</p><blockquote><p>aws budget setup 是 AWS 提供的一种用于创建和管理预算的命令行工具。使用该命令，你可以设置预算的各种参数，例如预算金额、时间周期、阈值等。aws budget setup 本身并不能直接保证费用不会超过预算，它更多地是用于创建和配置预算，并在达到或超过阈值时发送警报通知。</p></blockquote></li><li><p>列举EC2 type 的类型分类和适用场景</p><blockquote><p>a. 通用用途（General Purpose）：</p><ul><li>实例类型：T3、M5、M6g</li><li>适用场景：Web 服务器、中小型数据库、开发/测试环境、应用程序后端等通用计算工作负载。</li></ul><p>b. 计算优化（Compute Optimized）：</p><ul><li>实例类型：C5、C6g</li><li>适用场景：高性能计算、批处理作业、游戏服务器、科学模拟等需要强大计算能力的工作负载。</li></ul><p>c. 存储优化（Storage Optimized）：</p><ul><li>实例类型：I3、D2</li><li>适用场景：大规模数据库、分布式文件系统、数据仓库、大数据处理等需要高存储&gt;容量和低延迟存储性能的工作负载。</li></ul><p>d. 内存优化（Memory Optimized）：</p><ul><li>实例类型：R5、R6g、X1、X1e</li><li>适用场景：内存密集型应用程序、内存数据库、大规模缓存、大数据分析等需要大容量内存的工作负载。</li></ul><p>e.GPU 加速（GPU Instances）：</p><ul><li>实例类型：P3、G4、Inf1</li><li>适用场景：深度学习训练和推理、图形渲染、视频编码、密码破解等需要 GPU 加&gt;速的工作负载。</li></ul><p>f.FPGA 加速（FPGA Instances）：</p><ul><li>实例类型：F1</li><li>适用场景：加速定制计算任务、数据压缩、加密解密、搜索排序等需要 FPGA 加速的工作负载。</li></ul></blockquote></li></ol><ol start="7"><li><p>Security Groups rules can reference by Security Group这句话怎么理解？</p><blockquote><p>假设你有一个名为 Security Group A 的安全组，其中包含了一些实例，而你还有一个名为 Security Group B 的安全组，其中也包含了一些实例。你可以在 Security Group A 的规则中设置允许来自 Security Group B 的实例的流量访问。</p></blockquote></li><li><p>在AWS console上，EC2 instance connect 和 session manager这两种连接方式有什么不同？</p><blockquote><p>EC2 Instance Connect和Session Manager是AWS提供的两种连接EC2实例的方式，它们有一些不同之处：</p><ol><li>EC2 Instance Connect:</li></ol><ul><li>EC2 Instance Connect是一种基于SSH的连接方式，用于安全地连接到EC2实例。(SSH:22)</li><li>它允许你直接从AWS管理控制台或AWS CLI使用SSH密钥对连接到实例。</li><li>EC2 Instance Connect使用EC2实例上的公钥进行身份验证。</li><li>使用EC2 Instance Connect时，你需要在实例启动时配置正确的SSH密钥对，并确保在连接时使用正确的SSH密钥对。</li></ul><ol start="2"><li>Session Manager:</li></ol><ul><li>Session Manager是一种基于代理的连接方式，它不需要在实例上打开任何入站端口。</li><li>Session Manager通过AWS Systems Manager的功能提供安全的远程管理和访问控制。</li><li>它使用IAM角色和权限来控制对实例的访问，而不是使用SSH密钥对。</li><li>Session Manager提供了更高级的功能，如会话录制、访问审计和与AWS Systems Manager其他功能的集成。<br>总体而言，EC2 Instance Connect适合通过SSH连接到实例进行基本的维护和调试，而Session Manager提供了更多的功能和安全性，并能与AWS Systems &gt;Manager的其他功能集成，适用于需要更高级管理和访问控制的场景</li></ul></blockquote></li><li><p>AWS EC2中Tenacy是什么，有几种类型？</p><blockquote><p>在 AWS EC2 中，”tenancy”（托管类型）指的是您的 EC2 实例在物理硬件上的运行方式或托管方式。</p><ul><li>Shared Tenancy (默认)：这是默认的 tenancy 类型，也称为共享托管。在这种模式下，您的 EC2 实例与其他 AWS 客户的实例共享物理硬件。这是最经济和常见的选项，适用于大多数使用情况。</li><li>Dedicated Tenancy：这是一种专用托管类型，其中您的 EC2 实例在独立的物理硬件上运行，与其他 AWS 客户的实例隔离开来。这种模式提供更高的隔离和安全性，适用于对隔离性要求较高的工作负载，如合规要求或许可证限制。</li><li>Dedicated Host：这是一种完全专用的物理服务器托管类型，其中您租用整个物理主机（Host）来运行您的 EC2 实例。您完全控制该主机上的实例分配和部署，适用于具有对物理硬件配置和控制要求的工作负载。</li></ul></blockquote></li><li><p>EFS 是region级别还是global级别的？</p><blockquote><p>Amazon Elastic File System (EFS) 是在特定的 AWS 区域级别提供的，而不是全局级别。每个 AWS 区域都可以拥有一个或多个 EFS 文件系统。</p></blockquote></li><li><p>FSx</p><blockquote><ul><li>Amazon FSx for Windows File Server：适用于 Windows 应用程序的共享文件存储解决方案。它使用 SMB 协议，并且与 Windows 生态系统无缝集成。适合用于企业应用、共享文件存储、数据库备份等场景。</li><li>Amazon FSx for Lustre：适用于高性能计算和大规模数据处理的并行文件系统。它基于 Lustre 文件系统，并提供了高吞吐量和低延迟的存储性能。适合用于机器学习、高性能计算、媒体处理等场景。</li></ul><p>通过使用适当的协议和适配器，您可以将 Amazon FSx 文件系统挂载到本地服务器上，使其像本地文件系统一样可访问。这使您可以在本地服务器和 Amazon FSx 之间进行数据传输和共享，从而实现混合云环境或迁移工作负载的需求。</p></blockquote></li><li><p>ALB 和 NLB 适用场景</p><blockquote><p>ALB (Application Load Balancer)、NLB (Network Load Balancer) 和 GLB (Global Load Balancer) 是 Amazon Web Services (AWS) 提供的不同类型的负载均衡器，它们在不同的应用场景下有各自的优势。</p><ol><li>ALB (Application Load Balancer):</li></ol><ul><li>适用场景: ALB 主要用于应用层（第7层）的负载均衡，特别适用于 HTTP 和 HTTPS 流量的负载均衡。</li><li>功能特点: ALB 支持基于请求内容的路由，能够根据路径、主机名、请求头等信息将请求转发到不同的目标组 (Target Group)。</li><li>优势: ALB 具有高级的负载均衡功能，可以实现灵活的应用路由和请求转发，支持容器化应用和微服务架构。</li></ul><ol start="2"><li>NLB (Network Load Balancer):</li></ol><ul><li>适用场景: NLB 主要用于传输层（第四层）的负载均衡，适用于处理 TCP 和 UDP 流量的负载均衡。</li><li>功能特点: NLB 提供低延迟、高吞吐量的负载均衡，支持静态 IP 地址，适合于对连接状态要求较高的应用。</li><li>优势: NLB 在处理大流量和高并发请求时具有出色的性能和可伸缩性，适用于需要处理大量连接的应用。</li></ul><ol start="3"><li>GLB (Gateway Load Balancer): </li></ol><ul><li>用于网络层（第三层）</li><li>适用于企业对大流量进行安全GWLB可将需要扫描的流量转发到一组虚拟设备上，并实现健康检查、负载调度、粘性链接等管理功能。Gateway Load Balancer在OSI模型的第三层工作，并使用Geneve协议（RFC 8926）和GWLB metadata向执行扫描的虚拟设备转发网络流量。</li></ul></blockquote></li><li><p>S3 One Zone IA 和 S3 Standard IA 区别和适用场景</p><blockquote><p>S3 One Zone IA适用于对数据冗余性要求较低的场景，存储在单个可用区，成本较低。S3 Standard IA适用于对数据冗余性和可用性要求较高的场景，存储在多个可用区，成本相对较高。</p></blockquote></li><li><p>Snowball Edge 的两种类型和适用场景</p><blockquote><p>AWS Snowball Edge有两种类型：Snowball Edge Storage Optimized和Snowball Edge Compute Optimized。  </p><ul><li>Snowball Edge Storage Optimized适用于大规模数据(MAX80TB)迁移和存储，  </li><li>Snowball Edge Compute Optimized适用于边缘计算和数据处理场景。</li></ul></blockquote></li><li><p>Redshift是基于什么场景设计的呢？</p><blockquote><p>Amazon Redshift是专门设计用于大规模数据仓库和分析工作负载的云数据仓库服务。它的设计目标是支持高性能、高可靠性和高扩展性的数据处理。<br>Redshift适用于以下场景：数据仓库, 商业智能（BI）和数据分析, 大数据分析, 实时数据仓库等。</p></blockquote></li><li><p>AWS serverless的服务有哪些？</p><blockquote><ul><li>AWS Lambda：用于运行代码的事件驱动计算服务，无需管理服务器。</li><li>Amazon API Gateway：用于构建、部署和管理可扩展的API，可与Lambda函数或其他后端服务集成。</li><li>AWS Step Functions：一种有状态的服务器无服务工作流服务，用于协调多个Lambda函数和其他服务的执行。</li><li>Amazon DynamoDB：一种无服务器的键值对数据库服务，可提供高度可扩展和低延迟的数据存储。</li><li>Amazon S3：一种对象存储服务，用于存储和检索任意类型的数据，可与Lambda函数集成实现无服务器处理。</li><li>AWS AppSync：一种无服务器的后端服务，用于构建可扩展的API和实时应用程序。</li><li>Amazon Athena：一种无服务器查询服务，可在S3中直接查询和分析数据。</li><li>AWS Glue：一种无服务器的ETL（抽取、转换、加载）服务，用于数据准备和转换。<br>等等。。。</li></ul></blockquote></li><li><p>如何通过SSM访问EC2呢？</p><blockquote><p>AWS Systems Manager (SSM) 是一项 AWS 的 serverless 服务。它提供了一系列工具和功能，用于管理和操作 EC2 实例、虚拟机、容器、操作系统和应用程序。为了让 EC2 实例能够通过 SSM Shell 进行访问，需要以下步骤：</p><ol><li>在 EC2 实例上安装 SSM Agent。SSM Agent 是一种代理程序，用于与 SSM 服务进行通信。确保在 EC2 实例上安装并运行了最新版本的 SSM Agent。</li><li>为 EC2 实例分配具有适当权限的 IAM 角色。您需要创建一个 IAM 角色，并将其分配给 EC2 实例。该角色需要具有 AmazonSSMManagedInstanceCore 策略或自定义策略，以允许 EC2 实例与 SSM 服务进行通信。</li><li>确保 EC2 实例所在的安全组（Security Group）允许与 SSM 相关的流量。您需要确保安全组配置允许 EC2 实例与 SSM 服务进行通信。具体来说，您需要允许出站流量访问 SSM 服务的相关端口（如 443）。</li></ol></blockquote></li><li><p>route53中的SOA和NS 类型是什么，默认都有吗?</p><blockquote><p>在Amazon Route 53中，SOA (Start of Authority) 和 NS (Name Server) 是两种常见的DNS记录类型。它们在域名注册和DNS解析中起着重要的作用。</p><ol><li>SOA (Start of Authority) 记录：SOA记录指定了域名的授权服务器以及与该域名相关的其他重要信息，如域名的刷新时间、重试时间、过期时间等。SOA记录在域名的顶级域区域文件中定义，用于管理域名的DNS解析。</li><li>NS (Name Server) 记录：NS记录指定了为该域名提供DNS解析服务的名称服务器。这些名称服务器负责解析与该域名相关的DNS查询。通常，至少需要提供两个NS记录，以确保域名的可用性和冗余性。  </li></ol><p>在Route 53中，默认情况下，当您注册域名或使用Route 53作为域名的DNS服务时，会自动创建SOA和NS记录。这些记录将被分配给您的域名，并由Route 53管理。</p></blockquote></li><li><p>创建一个CloudFront组件，相当于在所有Edge Location都进行了CDN配置吗？</p><blockquote><p>创建一个 CloudFront 分发是将内容缓存到 AWS 全球边缘位置（Edge Locations）以提供低延迟和高性能的内容交付。但是，在创建 CloudFront 分发时，并不会立即在所有 Edge Locations 进行 CDN 配置。而是会根据网络拓扑和用户请求来选择合适的边缘位置进行内容缓存和交付。如果请求的内容尚未在该边缘位置缓存，则 CloudFront 会从源服务器获取内容，并将其缓存到该边缘位置以供后续请求使用。因此，CloudFront 通过在全球各个边缘位置缓存内容，提供了更快速和高效的内容交付。</p></blockquote></li><li><p>什么是SSE-KMS？</p><blockquote><p>SSE-KMS (Server-Side Encryption with AWS Key Management Service) 是 AWS 中一种用于服务器端加密的数据保护机制。它通过使用 AWS Key Management Service (KMS) 来管理密钥，并使用该密钥对存储在 AWS 服务中的数据进行加密和解密操作。</p></blockquote></li><li><p>S3 Transfer Acceleration是针对上传S3 File的一项加速技术方案?</p><blockquote><p>当启用 S3 Transfer Acceleration 后，您的上传请求将通过 CloudFront 边缘节点进行传输，而不是直接传输到 S3 存储桶所在的特定区域。CloudFront 边缘节点位于全球各个地理位置，它们之间的网络连接速度更快，可以提供更低的延迟和更高的带宽。</p><p>使用 S3 Transfer Acceleration，您可以通过在 S3 存储桶的 URL 中添加 “.s3-accelerate” 的子域名，例如 “bucket-name.s3-accelerate.amazonaws.com”，来上传文件。这样，您的文件将通过最接近客户端的 CloudFront 边缘节点进行传输，从而实现更快的上传速度。</p><p>需要注意的是，S3 Transfer Acceleration 对于小文件或距离 S3 存储桶所在区域较近的上传操作可能不会带来明显的性能改善。但对于大文件或距离较远的上传操作，它可以显著提高上传速度和效率。</p></blockquote></li><li><p>AWS的Edge Location是一种资源？</p><blockquote><p>Edge Location 是 AWS 全球基础设施的一部分，并与其他服务和功能密切集成，以提供更快速和可靠的网络体验。<br>AWS 的 Edge Location 是一种网络设施，用于分发内容和加速网络请求。Edge Location 是位于全球各个地理位置的边缘节点，它们与 AWS 的全球基础设施相连。每个 Edge Location 都具有高带宽连接，可以缓存内容并向用户提供低延迟的响应。</p></blockquote></li><li><p>AWS Shield</p><blockquote><p>AWS Shield 是一项由亚马逊网络服务（AWS）提供的托管的分布式拒绝服务（DDoS）保护服务。它旨在帮助保护 AWS 上的应用程序和资源免受网络攻击的影响。<br>AWS Shield 提供两个主要的服务层级：</p><ol><li>AWS Shield Standard：这是 AWS 提供的免费层级的 DDoS 保护服务。它会自动为所有 AWS 客户的应用程序和资源提供基本的 DDoS 防护。AWS Shield Standard 使用基于网络流量的算法来检测和缓解常见的 DDoS 攻击，如 SYN/ACK 攻击、UDP 反射攻击和 HTTP 慢速攻击。</li><li>AWS Shield Advanced：这是 AWS 提供的高级 DDoS 保护服务，需要额外的订阅费用。AWS Shield Advanced 提供了更强大的 DDoS 防护功能，包括更高级的检测和缓解机制，以及更强大的防御能力。它还提供实时攻击报告、专家支持和 DDoS 攻击的调查和响应。  </li></ol><p>AWS Shield 的目标是帮助客户保护其在 AWS 上运行的应用程序和资源免受 DDoS 攻击的影响，确保应用程序的可用性和稳定性。它提供了一系列的技术和服务，包括网络流量监控、攻击检测、流量过滤和缓解措施，以及专家支持和响应，以帮助客户应对各种类型和规模的 DDoS 攻击。</p></blockquote></li><li><p>pub/sub是什么模型？(SNS)</p><blockquote><p>发布/订阅（Pub/Sub）是一种消息传递模型，用于实现解耦和异步通信。在发布/订阅模型中，消息发布者（Publisher）将消息发布到特定的主题（Topic），而消息订阅者（Subscriber）则通过订阅该主题来接收相应的消息。<br>发布/订阅模型常用于构建事件驱动架构、消息队列、实时数据流处理等场景。它提供了一种灵活和可扩展的方式来处理消息传递，使不同组件或服务能够相互通信和协同工作，同时减少了耦合性和依赖性。</p></blockquote></li><li><p>AWS EventBridge Schedule模式和AWS Cronjob如何选择?</p><blockquote><ol><li>AWS EventBridge Schedule模式：<br>适用于事件驱动的架构：如果你的应用程序已经使用了EventBridge来处理其他事件，使用Schedule模式可以在同一事件总线上处理定时任务和其他事件，实现统一的事件驱动架构。<br>灵活的规则和目标配置：EventBridge Schedule模式允许你使用Cron表达式或固定频率配置任务触发规则，可以将事件发送到多种目标，如Lambda函数、SNS主题、SQS队列等。</li><li>CronJob：<br>直接的定时任务触发：如果你只需要简单地在固定的时间或时间间隔内触发定时任务，并不需要与其他事件处理或集成，使用CronJob是一个更简单直接的选择。<br>简化的配置：使用CronJob只需指定Cron表达式和要触发的任务或Lambda函数即可，不需要额外的规则和目标配置.  </li></ol><p>如果你的应用程序已经使用了EventBridge来处理其他事件，且需要在同一事件总线上处理定时任务，或者需要更灵活的规则和目标配置，那么可以选择AWS EventBridge Schedule模式。如果你只需要简单地触发定时任务，并且不需要与其他事件处理或集成，那么使用CronJob会更加简化配置和使用.</p></blockquote></li><li><p>VPC peering 的使用场景</p><blockquote><p>VPC peering是一种在Amazon Virtual Private Cloud（VPC）之间建立私有连接的方法。它允许您在不同的VPC之间进行直接的网络通信，就像它们属于同一个网络一样。以下是一些使用VPC peering的常见场景：</p><ol><li>多个VPC之间的通信：当您需要在多个VPC之间进行内部通信时，可以使用VPC peering来建立连接。这&gt;对于构建跨区域或跨账号的网络架构非常有用。</li><li>跨账号资源共享：如果您有多个AWS账号，并且希望共享资源或进行跨账号的数据传输，可以使用VPC &gt;peering来建立安全的连接。</li><li>跨区域数据复制：如果您有不同地理区域的VPC，并且需要在它们之间复制数据或进行备份操作，可以使&gt;用VPC peering来建立高速、低延迟的连接。</li><li>跨VPC访问共享服务：如果您有一些共享的服务或资源，例如数据库、认证服务或文件存储，您可以使用&gt;VPC peering来实现其他VPC访问这些服务。</li><li>逻辑隔离和安全性：使用VPC peering可以创建逻辑上隔离的网络环境，不同的VPC之间不会自动相互&gt;通信，提供更好的网络安全性和隔离性。</li></ol><p>总的来说，VPC peering提供了一种简单、安全且可扩展的方法，使不同的VPC能够直接通信，使您能够构建复杂的网络架构和应用程序。</p></blockquote></li><li><p>VPC Endpoint和VPC Endpoint service 适用场景呢?</p><blockquote><ul><li>VPC Endpoint用于访问AWS服务中的组件：VPC Endpoint允许您在VPC内部通过私有连接访问特定的AWS服务（S3、DynamoDB）[Gateway Endpoint（网关型终端节点）]。它是用于在VPC中直接访问这些AWS服务的方式，而无需经过公共Internet，从而提供更高的安全性和更快的网络访问速度。也可以用来访问其他AWS服务[Interface Endpoint（接口型终端节点]。</li><li>VPC Endpoint Service用于将自己的AWS服务托管到VPC上供其他AWS访问：VPC Endpoint Service是一种托管服务，它允许您将自己的服务或第三方服务连接到VPC，并通过私有连接让其他VPC中的资源访问这些服务。通过创建VPC Endpoint Service，您可以提供私有连接访问您的服务，而无需将流量路由到公共Internet，从而提高安全性和性能。</li></ul></blockquote></li><li><p>实现两个AWS账号之间的服务访问，需要进行双向配置。</p><blockquote><p>在接收方AWS账号（目标账号）中，您需要配置VPC Endpoint Service，以便将您的服务托管到VPC中，并允许其他AWS账号的VPC通过VPC Endpoint连接到您的服务。<br>在发送方AWS账号（请求账号）中，您需要配置VPC Endpoint，以便将您的VPC与接收方AWS账号中的VPC Endpoint建立连接。这样，您的VPC内的资源就可以通过VPC Endpoint直接访问接收方AWS账号中的服务，而无需通过公共网络。</p></blockquote></li><li><p>Organization 中SCP继承</p><blockquote><p>SCP(Service Control Policy) 继承遵循以下规则：</p><ul><li>组织根 SCP：在组织根 OU(Organization Unit) 中定义的 SCP 会自动应用于该 OU 下的所有子 OU 和账号。这意味着在根 OU 中定义的 SCP 将影响整个组织范围内的所有账号。</li><li>子 OU 继承：子 OU 可以继承其父 OU 定义的 SCP。这意味着在父 OU 中定义的 SCP 会自动应用于其下属的子 OU 和账号。子 OU 可以继承多个父 OU 的 SCP。</li><li>SCP 限制：子 OU 可以通过在其自身定义更严格的 SCP 来限制继承的权限。子 OU 定义的 SCP 将覆盖父 OU 定义的相同权限，即使父 OU 的 SCP 更宽松。</li></ul></blockquote><p>通过 SCP 继承，您可以在组织的不同层级上实现一致的访问控制策略，并确保所有账号遵循相同的安全性和合规性要求。这简化了权限管理和策略执行，使得在整个组织范围内的资源和服务都受到一致的访问控制限制。</p></li><li><p>AWS Cognito是一个AWS用户的SSO Server吗</p><blockquote><p>AWS Cognito可以与其他平台进行认证集成，允许用户使用他们在AWS账号中已有的凭证（用户名密码、社交媒体账号等）登录其他应用程序。这使得用户不需要再为不同的应用程序创建不同的账号和密码，而是可以使用他们在AWS账号中已有的凭证快速登录其他应用程序，从而提供更好的用户体验和简化身份验证流程。同时，AWS Cognito还支持标准的开放式身份验证（OAuth）和Security Assertion Markup Language（SAML）协议，使得与其他身份提供商和企业认证系统的集成变得更加简单。</p></blockquote></li><li><p>Cognito VS IAM Identity Center</p><blockquote><p>AWS Cognito 适用于构建应用程序的用户认证和管理，并在 AWS 环境内存储账号密码等凭证信息。而 IAM Identity Provider 则是将其他身份系统与 AWS 的身份访问控制进行集成，允许使用其他平台的用户凭证登录 AWS 资源。</p><ul><li><p>AWS Cognito: 在 AWS Cognito 中，账号和密码等用户凭证是由 AWS 管理和存储的。Cognito 提供了一个用户池（User Pool），您可以在这里管理用户的注册、登录和身份验证过程。您可以选择允许用户使用邮箱、手机号码、用户名等进行登录，并且 Cognito 会安全地存储这些凭证信息。</p></li><li><p>IAM Identity Provider: 在 IAM 中，身份提供商是指用于将其他身份系统（如企业目录、SAML 2.0 提供商等）集成到 IAM 中的一种机制。这样，您可以使用来自其他平台的身份信息来管理 AWS 资源的访问控制。这意味着用户可以使用其他身份系统的凭证进行登录并访问 AWS 资源。</p></li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Security认证与授权源码分析</title>
      <link href="2021/12/21/spring-security-ren-zheng-yu-shou-quan-yuan-ma-fen-xi/"/>
      <url>2021/12/21/spring-security-ren-zheng-yu-shou-quan-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security认证与授权源码分析"><a href="#Spring-Security认证与授权源码分析" class="headerlink" title="Spring Security认证与授权源码分析"></a>Spring Security认证与授权源码分析</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>任何系统服务的使用，安全问题不可忽视，对于系统而言，Authentication和Authorization是两个比较重要的概念，它们分别对应于用户认证和用户授权。</p><ul><li>Authentication: 认证是什么？认证是指用户身份的验证，即用户的<strong>身份</strong>是否合法，是否有效，是否可用。代表着的是<strong>可以访问系统</strong>的一个标志。<em>我可以吗？</em></li><li>Authorization: 授权是什么？授权是指用户对资源的访问权限，即用户对<strong>资源的访问权限</strong>是否合法，是否有效，是否可用。代表着的是<strong>可以访问资源</strong>的一个标志。<em>我能做什么？</em></li></ul><p>比如登录页面，必然是认证过程，而登录成功后，需要授权才能访问某些特殊页面，比如查看公司所有员工薪资等操作，这个过程就需要一定权限。</p><p>在Spring生态圈中，Spring-Security是主要负责系统认证与授权的重要组件，它是一个完整的认证框架，包含了认证、授权、访问控制、访问控制等等。</p><blockquote><p>Spring Security’s web infrastructure is based entirely on standard servlet filters.<br>Security的核心逻辑是基于Filter进行封装的，本质上就是在Http的请求链路上进行Filter的功能扩展。 </p></blockquote><p>在Java web中，一个request请求会经过一条过滤器链，最终到达servlet层面进行处理，这些过滤器的顺序是固定的，可以通过配置文件进行配置。在经过过滤器链的过程中会完成认证与授权，如果中间发现这条请求未认证或者未授权，会根据被保护API的权限去抛出异常，然后由异常处理器去处理这些异常。</p><p>如图所示：</p><img src="/2021/12/21/spring-security-ren-zheng-yu-shou-quan-yuan-ma-fen-xi/filter_flow.jpeg" class="" alt="filter_flow"><ul><li>黄色：SecurityContext安全上下文管理</li><li>绿色：认证过滤器</li><li>红色：授权过滤器</li><li>蓝色：异常处理过滤器</li></ul><p>其核心的认证与授权过程也是基于几个已定义好的Filter实现的，本文将针对认证与授权过程中使用的Filter源码分析，以梳理认证与授权具体流程。</p><h2 id="认证Authentication"><a href="#认证Authentication" class="headerlink" title="认证Authentication"></a>认证Authentication</h2><p>认证过程也是处于一个请求在经过过滤器链时某一过滤器环节。Filter便是过滤器的接口类。认证过程中最主要的Filter是<code>AbstractAuthenticationProcessingFilter</code>和<code>UsernamePasswordAuthenticationFilter</code>,而后者其实是前者的子类。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>认证时序图如下：（只记录了作者认为重要的步骤）</p><img src="/2021/12/21/spring-security-ren-zheng-yu-shou-quan-yuan-ma-fen-xi/authentication_sequence.png" class="" alt="authentication_flowchart"><p>接下来对时序图中涉及的类作用进行简要介绍：</p><ul><li><code>AbstractAuthenticationProcessingFilter</code>和<code>UsernamePasswordAuthenticationFilter</code>,它们的主要作用是获取用户名和密码，并进行认证以及认证成功和失败的处理操作，是认证流程中的核心。</li><li><code>ProviderManager</code> 认证管理中心，相当于一个策略模板，根据传入的认证信息，选择不同的认证处理器进行处理。达到了认证集中管理的效果。其本身不处理认证请求，而是将任务委托给一个配置好的<code>AuthenticationProvider</code>的列表，其中每一个<code>AuthenticationProvider</code>按序确认能否完成认证，每个provider如果认证失败，会抛出一个异常，如果认证通过，则会返回一个<code>Authentication</code>对象。</li><li><code>AbstractUserDetailsAuthenticationProvider</code>和<code>DaoAuthenticationProvider</code>,二者完成具体认证操作，其中<code>AbstractUserDetailsAuthenticationProvider</code>是一个抽象类，它实现了<code>AuthenticationProvider</code>接口，而<code>DaoAuthenticationProvider</code>是它的子类，它的主要作用是获取用户信息，并进行认证，以及构造认证成功<code>Authentication</code>对象。</li><li><code>JdbcUserDetailsManager</code>, <code>UserDetailsService</code>接口的实现类，实现从具体数据库查询<code>UserDetails</code>信息并返回。</li><li><code>UsernamePasswordAuthenticationToken</code>, <code>Authentication</code>的实现类，作为<code>Authentication</code>对象返回给<code>AbstractAuthenticationProcessingFilter</code>。</li></ul><p>以上便是认证流程中较为重要的角色的作用，接下来我们可对时序图具体流程结合源码进行分析，将摘取了作者个人认为较为重要的方法，若有不同见解，可查阅其他资料。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><code>AbstractAuthenticationProcessingFilter.doFilter</code></li></ol><p>一个request将经过此过滤器进行认证操作。认证成功则进入successfulAuthentication处理，失败则进入unsuccessfulAuthentication处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuthenticationProcessingFilter</span> <span class="token keyword">extends</span> <span class="token class-name">GenericFilterBean</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">,</span> <span class="token class-name">MessageSourceAware</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequestrequest</span><span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span><span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span><span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 根据request的url等信息来确定是否需要进行认证</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requiresAuthentication</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// [*重*]根据request信息中的username和password字段进行认证，并返回Authentication对象</span>                <span class="token class-name">Authentication</span> authenticationResult <span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attemptAuthentication</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>authenticationResult <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 设置session策略</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>sessionStrategy<span class="token punctuation">.</span><span class="token function">onAuthentication</span><span class="token punctuation">(</span>authenticationResult<span class="token punctuation">,</span> request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>continueChainBeforeSuccessfulAuthentiction<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 认证成功后的处理</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">successfulAuthentication</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> authenticationResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 认证失败后的处理</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InternalAuthenticationServiceExceptionvar5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"An internal erroroccurred while trying to authenticatethe user."</span><span class="token punctuation">,</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsuccessfulAuthenticatio</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AuthenticationException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsuccessfulAuthenticatio</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>UsernamePasswordAuthenticationFilter.attemptAuthentication</code></li></ol><p>在attemptAuthentication中，通过是否为POST请求决定是否进行认证操作，而具体认证由AuthenticationManager实现类完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UsernamePasswordAuthenticationFilter</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractAuthenticationProcessingFilter</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token class-name">Authentication</span> <span class="token function">attemptAuthentication</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 判断是否为POST请求</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>postOnly <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AuthenticationServiceException</span><span class="token punctuation">(</span><span class="token string">"Authentication method not supported: "</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 根据”username“和”password“字段获取用户名和密码</span>            <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainUsername</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>            username <span class="token operator">=</span> username <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> username <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>            username <span class="token operator">=</span> username<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainPassword</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>            password <span class="token operator">=</span> password <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> password <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token comment">// 根据用户名和密码构造一个`Authentication`对象authRequest</span>            <span class="token class-name">UsernamePasswordAuthenticationToken</span> authRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将request中的其他信息添加到`Authentication`对象</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDetails</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> authRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// [*重*]调用`ProviderManager(AuthenticationManager)`的authenticate进行认证</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAuthenticationManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span>authRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>ProviderManager.authenticate</code></li></ol><p>ProviderManager为AuthenticationManager的实现类，其根据传入的Authentication的具体类型选择相应的<code>AuthenticationProvider</code>进行认证</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderManager</span> <span class="token keyword">implements</span> <span class="token class-name">AuthenticationManager</span><span class="token punctuation">,</span> <span class="token class-name">MessageSourceAware</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// 根据传入的Authentication的具体类型选择相应的`AuthenticationProvider`进行认证</span>    <span class="token keyword">public</span> <span class="token class-name">Authentication</span> <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token class-name">Authentication</span> authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取类型</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Authentication</span><span class="token punctuation">></span></span> toTest <span class="token operator">=</span> authentication<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token class-name">Authentication</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Authentication</span> parentResult <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment">// 获取AuthenticationProvider的集合的迭代器</span>        <span class="token class-name">Iterator</span> var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getProviders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>var9<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">AuthenticationProvider</span> provider <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AuthenticationProvider</span><span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 判断类型是否支持</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>provider<span class="token punctuation">.</span><span class="token function">supports</span><span class="token punctuation">(</span>toTest<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// log配置</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// [*重*]调用具体的`AbstractUserDetailsAuthenticationProvider(AuthenticationProvider)`的authenticate进行认证</span>                    result <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 将authentication的details信息添加到result(Authentication对象)中</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">copyDetails</span><span class="token punctuation">(</span>authentication<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InternalAuthenticationServiceException</span> <span class="token operator">|</span> <span class="token class-name">AccountStatusException</span> var14<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 异常处理</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// TODO 为什么会用父结果</span>                parentResult <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> parentResult<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>             <span class="token comment">// 异常处理</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 其他操作</span>            <span class="token comment">// 返回构造的Authentication对象</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 异常处理</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>AbstractUserDetailsAuthenticationProvider.authenticate</code></li></ol><p>根据Username获取具体的UserDetails对象，并根据相关信息，构造一个<code>UsernamePasswordAuthenticationToken</code>对象，返回</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractUserDetailsAuthenticationProvider</span> <span class="token keyword">implements</span> <span class="token class-name">AuthenticationProvider</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">MessageSourceAware</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token class-name">Authentication</span> <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token class-name">Authentication</span> authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 断言传入的Authentication对象是否为UsernamePasswordAuthenticationToken类型，若不是，返回提示信息</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span><span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> authentication<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messages<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token string">"AbstractUserDetailsAuthenticationProvider.onlySupports"</span><span class="token punctuation">,</span> <span class="token string">"Only UsernamePasswordAuthenticationToken is supported"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineUsername</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 缓存</span>        <span class="token keyword">boolean</span> cacheWasUsed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token class-name">UserDetails</span> user <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userCache<span class="token punctuation">.</span><span class="token function">getUserFromCache</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cacheWasUsed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// [*重*]调用DaoAuthenticationProvider.retrieveUser方法获取用户信息UserDetails</span>                user <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">retrieveUser</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">)</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UsernameNotFoundException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 异常处理</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token class-name">Object</span> principalToReturn <span class="token operator">=</span> user<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>forcePrincipalAsString<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            principalToReturn <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// [*重*]根据Name, Credentials, Authorities 构造UsernamePasswordAuthenticationToken作为认证结果返回</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createSuccessAuthentication</span><span class="token punctuation">(</span>principalToReturn<span class="token punctuation">,</span> authentication<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><code>DaoAuthenticationProvider.retrieveUser</code></li></ol><p>在DaoAuthenticationProvider的retrieveUser中，根据用户名获取具体的用户信息UserDetails。(比如从缓存获取，从数据库获取，从内存获取等等，依据于具体的UserDetailsService的实现)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoAuthenticationProvider</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractUserDetailsAuthenticationProvider</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">UserDetails</span> <span class="token function">retrieveUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">UsernamePasswordAuthenticationToken</span> authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 防御 计时攻击</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareTimingAttackProtection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// [*重*]调用具体的UserDetailsService实现类的loadUserByUsername方法获取用户信息UserDetails</span>            <span class="token class-name">UserDetails</span> loadedUser <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getUserDetailsService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadUserByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>loadedUser <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalAuthenticationServiceException</span><span class="token punctuation">(</span><span class="token string">"UserDetailsService returned null, which is an interface contract violation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> loadedUser<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>         <span class="token comment">// 异常处理</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，Security中认证相关的基础类的方法实现已完成整理，若读者还有疑惑，可自行Debug，跟入源码进行查看，或梳理简单Flowchart进行总结。</p><p>认证成功后的处理，在Security中的<code>AuthenticationSuccessHandler</code>中，关于认证成功后的处理，即将认证成功的Authentication对象，放入SecurityContextHolder中，并跳转到目标页面。</p><h2 id="授权Authorization"><a href="#授权Authorization" class="headerlink" title="授权Authorization"></a>授权Authorization</h2><blockquote><p>根据系统设置的安全策略或者安全规则，用户可以访问而且只能访问自己被授权的资源。比如，超级管理员和普通管理员有不同的权限，比如黄金会员和白银会员也有不同的权限，这些都是权限管理。</p></blockquote><p>RBAC（Role-based access control）权限管理策略需要三个对象</p><blockquote><p>用户：主要包含用户名，密码和当前用户的角色信息，可实现认证操作;<br>角色：主要包含角色名称，角色描述和当前角色拥有的权限信息，可实现授权操作;<br>权限：权限也可以称为菜单，主要包含当前权限名称，url地址信息可实现动态展示菜单;</p></blockquote><p>那么，在Spring Security中，默认授权过程是如何进行的呢？我们接下来继续分析。</p><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><p>授权时序图如下：（只记录了作者认为重要的步骤）</p><img src="/2021/12/21/spring-security-ren-zheng-yu-shou-quan-yuan-ma-fen-xi/authorization_sequence.png" class="" alt="authentication_flowchart"><p>接下来对时序图中涉及的类作用进行简要介绍：</p><ul><li><code>FilterSecurityInterceptor</code>和<code>AbstractSecurityInterceptor</code>, 后者是前者的子类。其主要作用是将认证信息从当前请求上下文中取出来，对请求的资源做权限判断，如果无权访问相应的资源，则抛出异常，由<code>ExceptionTranslationFilter</code>进行处理，若至执行结束，都未抛出异常，则表明对当前请求的资源有权访问。</li><li><code>DefaultFilterInvocationSecurityMetadataSource</code>, 它是<code>SecurityMetadataSource</code>的实现类之一，默认配置使用此类，目的是从此类中获取当前请求的资源所需要的权限信息。比如有的权限信息会以<code>WebExpressionConfigAttribute</code>对象形式保存。</li><li><code>AffirmativeBased</code>, 它是<code>AccessDecisionManager</code>的实现类之一，默认配置使用此类，目的是对当前请求的资源和用户的角色信息进行权限判断，是具体进行授权验证的类。<code>AccessDecisionManager</code>有三种具体实现类：<ul><li><code>AffirmativeBased</code>：任一个投票器通过即允许访问。（一票通过制）</li><li><code>UnanimousBased</code>：投票器通过半数即运行访问。（少数服从多数制）</li><li><code>ConsensusBased</code>：所有投票器通过才允许访问。（一票否决制）</li></ul></li><li><code>ExceptionTranslationFilter</code>, 它是<code>Filter</code>的子类，也是一个异常处理类，此处其用于处理<code>FilterSecurityInterceptor</code>抛出的<code>AccessDeniedException</code>异常，如果没有抛出异常，则不会执行此类。同时，也会在认证阶段处理<code>AuthenticationException</code>。</li><li><code>LoginUrlAuthenticationEntryPoint</code>, <code>AuthenticationEntryPoint</code>子类，<code>ExceptionTranslationFilter</code>使用一个<code>AuthenticationEntryPoint</code>在需要的时候来启动表单认证流程，默认使用的实现是类<code>LoginUrlAuthenticationEntryPoint</code>。<code>LoginUrlAuthenticationEntryPoint</code>带有一个属性loginFormUrl指向表单登录页面的位置，基于此可以构建到表单登录页面的重定向URL。如果该属性是一个绝对路径URL，则可以直接用于重定向。</li></ul><p>以上便是认证流程中较为重要的角色的作用，接下来我们可对时序图具体流程结合源码进行分析，将摘取了作者个人认为较为重要的方法，若有不同见解，可查阅其他资料。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><code>FilterSecurityInterceptor.invoke</code></li></ol><p>构造FilterInvocation保存当前Filter的相关信息，并通过beforeInvocation方法对当前用户请求的资源进行调用前的权限判断。若无权访问，则抛出<code>AccessDeniedException</code>异常；否则，执行正常调用资源流程。<br>虽其中也有获取资源后的权限判断操作，但本文不深入查看，可自行了解。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterSecurityInterceptor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSecurityInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">// FilterInvocation保存一些Filter相关信息</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">FilterInvocation</span> filterInvocation<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 根据request的header内信息判断是否使用FilterInvocation，FilterInvocation是把doFilter传进来的request,response和FilterChain对象保存起来，供FilterSecurityInterceptor的处理代码调用。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isApplied</span><span class="token punctuation">(</span>filterInvocation<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> thisobserveOncePerRequest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            filterInvocation<span class="token punctuation">.</span><span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>filterInvocation<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> filterInvocation<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>filterInvocation<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observeOncePerRequest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                filterInvocation<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"__spring_security_filterSecurityInterceptor_filterApplied"</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// `FilterSecurityInterceptor`是过滤器链上最后一个过滤器，因此在下一行主要是针对调用前进行授权验证操作。</span>            <span class="token comment">// [*重*]根据方法名描述是在调用具体的Filter前进行的处理，其内处理在调用前具体是否授权操作</span>            <span class="token class-name">InterceptorStatusToken</span> token <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">beforeInvocation</span><span class="token punctuation">(</span>filterInvocation<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 具体去调用FilterInvocation的doFilter方法执行过滤</span>                filterInvocation<span class="token punctuation">.</span><span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>filterInvocation<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> filterInvocation<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 是否更新SecurityContext</span>                <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finallyInvocation</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 与beforeInvocation相对，afterInvocation是在调用后进行的处理，其内处理在调用后具体是否授权操作。本文主要展开beforeInvocation方法。</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">afterInvocation</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>AbstractSecurityInterceptor.beforeInvocation</code></li></ol><p>在调用beforeInvocation方法时，会进入父类<code>AbstractSecurityInterceptor</code>的<code>beforeInvocation</code>方法。</p><ul><li>首先会根据<code>SecurityMetadataSource</code>获取当前请求受保护资源所需要的权限信息，若是公开资源，直接通过。否则，进入授权流程。<code>SecurityMetadataSource</code>的默认实现类是<code>DefaultFilterInvocationSecurityMetadataSource</code>。</li><li>之后调用<code>attemptAuthorization</code>方法，判断是否有权限访问受保护的安全对象object。<code>attemptAuthorization</code>方法内部最重要的是<code>this.accessDecisionManager.decide(authenticated, object, attributes);</code>。默认是根据<code>AccessDecisionManager</code>的实现类<code>AffirmativeBased</code>来判断是否有权限访问受保护的安全对象object。</li><li>在<code>AffirmativeBased</code>的<code>decide</code>方法内部，会调用<code>AccessDecisionVoter</code>的<code>supports</code>方法，判断当前<code>AccessDecisionVoter</code>是否支持当前请求的安全对象object。若通过，则正常获取受保护资源。验权失败，则抛出<code>AccessDeniedException</code>异常。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractSecurityInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">,</span> <span class="token class-name">MessageSourceAware</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">InterceptorStatusToken</span> <span class="token function">beforeInvocation</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// [*重*]获取某个受保护的安全对象object的所需要的权限信息,是一组ConfigAttribute对象的集合</span>            <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigAttribute</span><span class="token punctuation">></span></span> attributes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainSecurityMetadataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// log 与 EventPublisher 的调用等</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">credentialsNotFound</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>messages<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token string">"AbstractSecurityInterceptor.authenticationNotFound"</span><span class="token punctuation">,</span> <span class="token string">"An Authentication object was not found in the SecurityContext"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> object<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 获取当前安全上下文的Authentication对象</span>                <span class="token class-name">Authentication</span> authenticated <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">authenticateIfRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// [*重*]根据当前上下文的Authentication对象和受保护的安全对象object的权限信息，判断是否有权限访问受保护的安全对象object</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attemptAuthorization</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> attributes<span class="token punctuation">,</span> authenticated<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// log 与 EventPublisher 的调用</span>                <span class="token comment">// 用户可能希望使用不同的Authentication替换SecurityContext中的Authentication，该身份验证由AccessDecisionManager调用RunAsManager来处理。 </span>                <span class="token class-name">Authentication</span> runAs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>runAsManager<span class="token punctuation">.</span><span class="token function">buildRunAs</span><span class="token punctuation">(</span>authenticated<span class="token punctuation">,</span> object<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>runAs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 使用runAs更新当前安全上下文</span>                    <span class="token comment">// ......</span>                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">InterceptorStatusToken</span><span class="token punctuation">(</span>origCtx<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> attributes<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 保存当前安全上下文，受保护资源所要求权限信息，受保护资源对象</span>                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">InterceptorStatusToken</span><span class="token punctuation">(</span><span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> attributes<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">attemptAuthorization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigAttribute</span><span class="token punctuation">></span></span> attributes<span class="token punctuation">,</span> <span class="token class-name">Authentication</span> authenticated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 默认是根据`AccessDecisionManager`的实现类`AffirmativeBased`来判断是否有权限访问受保护的安全对象object。(一票通过制)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>accessDecisionManager<span class="token punctuation">.</span><span class="token function">decide</span><span class="token punctuation">(</span>authenticated<span class="token punctuation">,</span> object<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AccessDeniedException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// log 与 EventPublisher 的调用</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>ExceptionTranslationFilter.doFilter</code></li></ol><p><code>ExceptionTranslationFilter</code>处理。若是抛出了<code>AccessDeniedException</code>异常，则会调用<code>handleAccessDeniedException</code>方法，进行异常处理。<br>异常处理分两类情况：</p><ul><li>response.sendError(HttpServletResponse.SC_FORBIDDEN) 发送403错误</li><li>sendStartAuthentication 发送认证请求</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTranslationFilter</span> <span class="token keyword">extends</span> <span class="token class-name">GenericFilterBean</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSourceAware</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 无异常，则继续执行</span>            chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> var7<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var8<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment">// 处理SpringSecurityException</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleSpringSecurityException</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span><span class="token punctuation">)</span>securityException<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleSpringSecurityException</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">,</span> <span class="token class-name">RuntimeException</span> exception<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 处理认证异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exception <span class="token keyword">instanceof</span> <span class="token class-name">AuthenticationException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleAuthenticationException</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">AuthenticationException</span><span class="token punctuation">)</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 处理访问拒绝异常</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>exception <span class="token keyword">instanceof</span> <span class="token class-name">AccessDeniedException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleAccessDeniedException</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">AccessDeniedException</span><span class="token punctuation">)</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleAccessDeniedException</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">,</span> <span class="token class-name">AccessDeniedException</span> exception<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Authentication</span> authentication <span class="token operator">=</span> <span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Spring Security为了兼容未登录的访问，也走一套认证流程，使用匿名用户</span>        <span class="token keyword">boolean</span> isAnonymous <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authenticationTrustResolver<span class="token punctuation">.</span><span class="token function">isAnonymous</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果是非匿名用户，并且未开启RememberMe功能，则直接处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnonymous <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>authenticationTrustResolver<span class="token punctuation">.</span><span class="token function">isRememberMe</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 处理访问拒绝情况，实际是response.sendError</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>accessDeniedHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 跳转到登录页面，发送认证请求，具体是LoginUrlAuthenticationEntryPoint的commence方法</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sendStartAuthentication</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientAuthenticationException</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>messages<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token string">"ExceptionTranslationFilter.insufficientAuthentication"</span><span class="token punctuation">,</span> <span class="token string">"Full authentication is required to access this resource"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，Security中授权相关的基础类的方法实现已完成整理。决定是否授权的是<code>AccessDecisionManager</code>，它是一个授权决策管理器，它决定了用户是否有权限访问受保护的安全对象object。<br>相信读者阅读至此，也对授权流程有了一定认识，当然也建议自行Debug跟读代码更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认证与授权是服务的基本功能，本文主要根据Spring Security中的认证与授权流程的源码，进行分析解读。即使不适用默认配置，如要自定义认证与授权流程，相信也可根据本文所涉及的类进行继承自定义实现。</p><p>当然，本文讲解的流程比较基础，在Spring Security还涉及很多方面，比如：</p><ul><li>RememberMe: 实现记住我功能，可以记住用户的登录信息，以便下次自动登录。<code>RememberMeAuthenticationFilter</code> 和 <code>RememberMeServices</code>。</li><li>SecurityContextHolder: 如何让当前应用持有的当前用户的权限信息。 <code>SecurityContextPersistenceFilter</code> 和 <code>SecurityContextHolder</code></li><li>JWT Token: 实现JWT Token的生成和验证</li></ul><p>以及与Spring Security相关的一些Library，比如：Spring-Social, Spring-Security-Oauth.</p><p>徐徐展开，Spring生态的庞大。</p><p>路漫漫其修远兮，吾将上下而求索。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://juejin.cn/post/6846687598442708999#heading-13">SpringSecurity+JWT认证流程解析</a></li><li><a href="https://cdrcool.github.io/2020/03/07/Spring%20Security%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E6%8E%88%E6%9D%83/">Spring Security 参考文档-授权</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Authorization </tag>
            
            <tag> Spring-Security </tag>
            
            <tag> Springboot </tag>
            
            <tag> Authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How Config Microservice Metrics for Monitor</title>
      <link href="2021/08/27/how-config-microservice-metrics-for-prometheus-monitor/"/>
      <url>2021/08/27/how-config-microservice-metrics-for-prometheus-monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="配置Springboot-Nginx服务以便于监控服务状态"><a href="#配置Springboot-Nginx服务以便于监控服务状态" class="headerlink" title="配置Springboot/Nginx服务以便于监控服务状态"></a>配置Springboot/Nginx服务以便于监控服务状态</h1><p><strong>要点</strong>：本文旨在记录如何通过Grafana+Prometheus 监控K8S内部署的无公网域名服务的健康状态。Grafana作为一个展示平台，其更多用于数据展示分析汇总，数据来源于Prometheus，因此，Prometheus在监测链路中才是最主要的负责Scrap服务状态数据的服务。在各大论坛博客出处，已有如何通过配置Grafana+Prometheus来获取服务状态，但鲜有人讲述如何配置服务以便于Prometheus去抓取数据。因此，本文<strong>重点在于讲述如何通过配置Springboot服务和Nginx服务暴露其Metric监控数据接口</strong>，以供Prometheus调用消费。</p><p>一言蔽之，Prometheus即便已知如何Scrap数据，当被监测方不去提供数据接口，其仍旧无意义，即单相思总是不行的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着云部署的发展，现在越来越多服务部署在云服务上，比如AWS、阿里云等等。而其部署平台核心大多都与K8S有关。</p><p>一个服务的健康与否，应当能及时给予监测结果。</p><p>试想以下情况，一名开发人员只注重业务代码开发，从未考虑服务健康状态如何监测，那一旦服务出现任何问题，都将致使服务无效，更别说去定位业务代码的问题。</p><p>因此，我们能知道，监测服务健康状态是具有十分重要意义的。</p><p><strong>公有域名监测</strong><br>一般来说，当我们服务部署后，拥有公网域名，可以通过Pingdom平台去监测轮询监测服务健康状态，其原理在于轮询所部属服务的某个API接口并判断返回状态码。<br>BTW，对于SpringBoot服务，框架可以通过配置文件暴露出health check endpoint以供监测平台进行查询。而其他框架的服务，若不自带健康监测endpoint，也可以通过自定义一个endpoint用于监测。</p><p>但有时我们需要监测部署在云平台上却又没有公网域名的服务，应该怎么做呢？<br>对于K8S而言，其可以通过部署Grafana+Prometheus方式直接监测服务的具体状态。<br>具体监控数据由被监测服务决定，其实很多状态数据都由框架生成，当然也可自定义。<br>K8S服务监控可阅读此文: <a href="https://zhuanlan.zhihu.com/p/100406234">K8S监控简介</a></p><p>了解K8S监控基本原理后，接下来将进入正题：</p><p>在各大论坛博客出处，已有如何通过配置Grafana+Prometheus来获取服务状态，随手一搜便是许多。<br>但是本文不去讲上游端如何抓取数据，而是分析下游端如何暴露数据以供抓取，<br>这便是本文主题：如何配置Springboot 服务和Nginx服务以供Prometheus监控健康状态。</p><h2 id="Springboot-服务"><a href="#Springboot-服务" class="headerlink" title="Springboot 服务"></a>Springboot 服务</h2><p>目前而言，大部分后端服务都采用了Springboot框架，因此，了解如何配置暴露Springboot服务的健康监测端口十分必要。</p><p>正因为框架帮助开发人员封装了很多方法，对于Springboot服务，其已经具有了很多健康监测接口，比如<code>health、info、metrics</code>。主要依靠Springboot Actuator。<br>具体了解Springboot Actuator 可查看<a href="http://www.ityouknow.com/springboot/2018/02/06/spring-boot-actuator.html">使用 Spring Boot Actuator 监控应用</a></p><p>了解基本概念后，可以查看如何简单配置使用Actuator。</p><p>若需要暴露某些Actuator接口以便于使用，可在<code>*.properties</code>文件增加以下配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># expose Actuator endpoint for prometheus</span><span class="token comment"># base-path default is /actuator</span><span class="token attr-name">management.endpoints.web.base-path</span><span class="token punctuation">=</span><span class="token attr-value">/custom-prefix</span><span class="token comment"># exposure include `/health` `metrics` `/prometheus`</span><span class="token attr-name">management.endpoints.web.exposure.include</span><span class="token punctuation">=</span><span class="token attr-value">health,metrics,prometheus</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处需注意：若要修改base-path，就要使用第一个属性，若要暴露任何已定义Actuator接口，则在第二个属性后新增即可。</p><p>这里最主要的是增加了<code>prometheus</code>接口。其可将Actuator的<code>/metrics</code>(报告各种应用程序度量信息)的数据汇总成prome可识别的格式暴露在<code>/prometheus</code>接口。</p><p>若要使用<code>/prometheus</code>接口，还需要再Springboot服务中引入一个Library，具体添加方式为：在<code>build.gradle.kts</code>文件内的<code>dependencies</code>增加新依赖。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">implementation</span><span class="token punctuation">(</span><span class="token string">"io.micrometer:micrometer-registry-prometheus:1.7.0"</span><span class="token punctuation">)</span><span class="token comment">// 注意：这是kotlin的gradle文件写法，如果是groove的gradle文件请自行更改符号格式。如果从来不了解gradle的DSL语法，请上网查阅</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此，当在本地启动服务后，打开<code>localhost:8080/custom-prefix/prometheus</code>便能看到相关的metrics数据。当然其他接口下也有相应数据。</p><blockquote><p>NOTE 引用：<a href="http://www.ityouknow.com/springboot/2018/02/06/spring-boot-actuator.html">使用 Spring Boot Actuator 监控应用</a></p></blockquote><blockquote><table><thead><tr><th align="left">HTTP 方法</th><th align="left">路径</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">/auditevents</td><td align="left">显示应用暴露的审计事件 (比如认证进入、订单失败)</td></tr><tr><td align="left">GET</td><td align="left">/beans</td><td align="left">描述应用程序上下文里全部的 Bean，以及它们的关系</td></tr><tr><td align="left">GET</td><td align="left">/conditions</td><td align="left">就是 1.0 的 /autoconfig ，提供一份自动配置生效的条件情况，记录哪些自动配置条件通过了，哪些没通过</td></tr><tr><td align="left">GET</td><td align="left">/configprops</td><td align="left">描述配置属性(包含默认值)如何注入Bean</td></tr><tr><td align="left">GET</td><td align="left">/env</td><td align="left">获取全部环境属性</td></tr><tr><td align="left">GET</td><td align="left">/env/{name}</td><td align="left">根据名称获取特定的环境属性值</td></tr><tr><td align="left">GET</td><td align="left">/flyway</td><td align="left">提供一份 Flyway 数据库迁移信息</td></tr><tr><td align="left">GET</td><td align="left">/liquidbase</td><td align="left">显示Liquibase 数据库迁移的纤细信息</td></tr><tr><td align="left">GET</td><td align="left">/health</td><td align="left">报告应用程序的健康指标，这些值由 HealthIndicator 的实现类提供</td></tr><tr><td align="left">GET</td><td align="left">/heapdump</td><td align="left">dump 一份应用的 JVM 堆信息</td></tr><tr><td align="left">GET</td><td align="left">/httptrace</td><td align="left">显示HTTP足迹，最近100个HTTP request/repsponse</td></tr><tr><td align="left">GET</td><td align="left">/info</td><td align="left">获取应用程序的定制信息，这些信息由info打头的属性提供</td></tr><tr><td align="left">GET</td><td align="left">/logfile</td><td align="left">返回log file中的内容(如果 logging.file 或者 logging.path 被设置)</td></tr><tr><td align="left">GET</td><td align="left">/loggers</td><td align="left">显示和修改配置的loggers</td></tr><tr><td align="left">GET</td><td align="left">/metrics</td><td align="left">报告各种应用程序度量信息，比如内存用量和HTTP请求计数</td></tr><tr><td align="left">GET</td><td align="left">/metrics/{name}</td><td align="left">报告指定名称的应用程序度量值</td></tr><tr><td align="left">GET</td><td align="left">/scheduledtasks</td><td align="left">展示应用中的定时任务信息</td></tr><tr><td align="left">GET</td><td align="left">/sessions</td><td align="left">如果我们使用了 Spring Session 展示应用中的 HTTP sessions 信息</td></tr><tr><td align="left">POST</td><td align="left">/shutdown</td><td align="left">关闭应用程序，要求endpoints.shutdown.enabled设置为true</td></tr><tr><td align="left">GET</td><td align="left">/mappings</td><td align="left">描述全部的 URI路径，以及它们和控制器(包含Actuator端点)的映射关系</td></tr><tr><td align="left">GET</td><td align="left">/threaddump</td><td align="left">获取线程活动的快照</td></tr></tbody></table></blockquote><p>可能看到这里，读者要说，这不都是基操，有何必要再写出来，随便一篇博客都比这份清晰深入。<br>但是其实希望自己明白，因此梳理一遍最近所遇相关问题，其次便于之后再遇到相似问题查找方便，最后，也会<strong>附上Springboot如何注册自定义Metrics数据</strong>的方法。</p><p><strong>自定义Metrics数据</strong></p><p>正如之前所说，部分情况下，我们需要监测内部服务的健康状态，此时，并不需要过多的数据描述，只需要一个合适的metric作为服务健康与否的指标即可。但是当配置完服务的<code>actuator</code>和<code>/proemtheus</code>后，发现其内更多的是JVM的相关数据，并没有一个明确的指标作为数据源。</p><p>此时，我们回想之前所说，Springboot 已经配置了health check endpoint，那么，是否可以通过自定义metric将health check结果注册进<code>MeterRegistry</code>内进而实现将数据暴露在<code>/prometheus</code>接口内呢？答案当然是肯定的</p><p><em>Springboot <code>MeterRegistry</code> 相关可查看：<a href="https://cloud.tencent.com/developer/article/1486382">JVM应用度量框架Micrometer</a></em></p><p>思路及方法参考Stack Overflow论坛。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token operator">..</span><span class="token punctuation">.</span><span class="token comment">// 使用MeterRegistry 注册自定义的 gauge（量值）类型数据，将定期轮询health check endpoint结果并将值赋给自定义指标</span><span class="token comment">// 服务的health check的结果来源于Springboot容器内的HealthEndpoint bean。</span><span class="token annotation builtin">@Configuration</span><span class="token keyword">class</span> <span class="token function">MyHealthMetricsConfig</span><span class="token punctuation">(</span>customerMeterRegistry<span class="token operator">:</span> MeterRegistry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation builtin">@Autowired</span>    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> myHealthEndpoint<span class="token operator">:</span> HealthEndpoint    <span class="token keyword">private</span> <span class="token keyword">val</span> myHealthCheck<span class="token operator">:</span> AtomicInteger<span class="token operator">?</span> <span class="token operator">=</span> customerMeterRegistry<span class="token punctuation">.</span><span class="token function">gauge</span><span class="token punctuation">(</span><span class="token string">"health_check"</span><span class="token punctuation">,</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token annotation builtin">@Scheduled</span><span class="token punctuation">(</span>fixedRateString <span class="token operator">=</span> <span class="token string">"60000"</span><span class="token punctuation">,</span> initialDelayString <span class="token operator">=</span> <span class="token string">"10000"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">schedulingTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myHealthCheck<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">myHealthToCode</span><span class="token punctuation">(</span>myHealthEndpoint<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">myHealthToCode</span><span class="token punctuation">(</span>endPoint<span class="token operator">:</span> HealthEndpoint<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">&#123;</span>          <span class="token comment">// 监测服务healthc 端点的的结果状态，up 为1 ，非up 均为0。 以数值结果代表服务健康状态</span>            <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>endPoint<span class="token punctuation">.</span><span class="token function">health</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>status <span class="token operator">==</span> Status<span class="token punctuation">.</span>UP<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，可以在<code>/promtheus</code>接口查询到命名为<code>health_check</code>的数据结果。如何去使用数据便在消费端去自定义了。</p><p>此方法不仅可用于定义一个健康监测指标，若有任何其他需要自定义的指标数据，也可使用此部分代码套路进行声明、注册、赋值操作。</p><p>后端Springboot服务具体配置已梳理完结，若之后有新增信息，会进行补充说明。<br>之后会进行前端Nginx配置简单分析，因Nginx是个中间件，不像框架已做一部分工作，因此还需一些新引入配置，接下来我们来看具体如何配置Nginx已暴露数据供监测方使用。</p><h2 id="Nginx-服务"><a href="#Nginx-服务" class="headerlink" title="Nginx 服务"></a>Nginx 服务</h2><p>前端大部分服务都是已打包完成的<code>html/css/js</code>文件，实际部署时，只是将相应的文件放在Nginx服务器上，并对Nginx服务进行简单配置即可。因此前端服务的监测主要集中在监测Nginx服务数据状态，而Nginx服务作为代理中间件，其内会接受发送大量的Http请求，因此通过监测Http请求的一些数据，便可实现对部署在Nginx上的服务状态进行监测。</p><p>如上所述，Nginx与Springboot不同，并不能通过简单配置便可是Prome直接获取到Nginx相关的服务状态数据。但，车到山前必有路，已有很多服务可以作为Nginx和Prometheus通信的桥梁，实现将Nginx数据汇总整理暴露成metric结果形式的数据供Prometheus消费。</p><p>常用的有两种:</p><ul><li><a href="https://github.com/nginxinc/nginx-prometheus-exporter">NGINX Prometheus Exporter</a>: <a href="https://nginx.org/">NGINX</a> exposes a handful of metrics via the <a href="https://nginx.org/en/docs/http/ngx_http_stub_status_module.html#stub_status">stub_status page</a></li><li><a href="https://github.com/martin-helmich/prometheus-nginxlog-exporter">NGINX-to-Prometheus log file exporter</a>: Helper tool that continuously reads an NGINX log file (or any kind of similar log file) and exports metrics to Prometheus.</li></ul><p>具体如何配置以实现桥梁作用，和已定义的metric可直接查看其<strong>Github的主页README文档</strong>，十分详细，此处不再阐述基本概念内容。</p><p>接下来进行一个Demo实现描述具体如何配置</p><p><strong>Demo示例</strong>：描述如何使用NGINX-to-Prometheus log file exporter 实现step by step完成监测Nginx服务健康状态的配置。</p><p>下图简单展示了Nginx 和 Prometheus_nignxlog_exporter 以及 Prometheus 和 Grafana的 关系。</p><p>由 Prometheus_nignxlog_exporter服务的作用可知，其主要作为Nginx和Prometheus的中间桥梁，主要通过收集Nginx的log日志，进而整理出一份关于Nginx服务的监控指标数据结果，并将结果暴露给Prometheus使用。具体指标可查Github文档。</p><p>任何事务的协作都需双方同意，因此，在使用Prometheus_nignxlog_exporter时需要配置Nginx服务保证将log日志输出至某个位置，比如将log输出至<code>&lt;IP&gt;:&lt;PORT&gt;</code>。同时配置Prometheus_nignxlog_exporter的监听地址。即可实现nignxlog_exporter获取Nginx log进而依据日志整理Nginx服务的状态数据。同样，Prometheus如何获取Nginx服务的状态数据，即通过监听Prometheus_nignxlog_exporter的某个暴露地址，通过配置轮询收集状态数据。<br>至于Prometheus和Grafana，不是此文重点，不再阐述。</p><img src="/2021/08/27/how-config-microservice-metrics-for-prometheus-monitor/image-20210831202412690.png" class="" alt="image-20210831202412690"><p>经过简单的梳理，相信读者老爷们已经有一定了解，具体配置可归纳为以下几步：</p><ol><li>在Nginx conf 文件中，增加相关log format定义和log 输出地址</li><li>在服务中新增prometheus_nginxlog_exporter容器，并设置其expose数据指标的Port和API地址（API 默认为<code>/metrics</code>）</li><li>设置prometheus_nginxlog_exporter的配置文件，主要设置source logs的 <code>&lt;IP&gt;:&lt;PORT&gt;</code> 和其他针对数据的处理。</li><li>配置Prometheus以抓取prometheus_nginxlog_exporter数据指标，根据其第二步expose的Port和API地址设置。</li><li>配置Grafana以根据具体metric选择展示的数据。</li></ol><p>接下来，通过一部分代码展示如何配置Nginx和prometheus_nginxlog_exporter。</p><p><strong>Nginx 配置</strong></p><p>在Nginx配置文件中新增log format格式和access_log参数</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">log_format</span> prometheus_exporter_log_format <span class="token string">'$remote_addr - $remote_user [$time_local] '</span><span class="token string">'"$request_uri" $request_time $status'</span><span class="token punctuation">;</span><span class="token keyword">access_log</span> syslog<span class="token punctuation">:</span><span class="token keyword">server</span><span class="token operator">=</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">88888</span> prometheus_exporter_log_format<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义一个prometheus_exporter_log_format代表log格式。使用access_log输出system logs至<code>127.0.0.1:88888</code>，其log格式依照prometheus_exporter_log_format定义。</p><p><strong>prometheus_nginxlog_exporter 配置</strong><br>Nginx已将logs输出，因此需要增加相关配置文件，此处不展示如何在一个服务内启动一个prometheus_nginxlog_exporter。<br>简易版配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">listen</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">4040</span>  <span class="token comment"># metrics_endpoint 默认为 "/metrics"</span>  <span class="token key atrule">metrics_endpoint</span><span class="token punctuation">:</span> <span class="token string">"/api/nginx/metrics"</span><span class="token key atrule">enable_experimental</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">namespaces</span><span class="token punctuation">:</span><span class="token comment"># metrics前缀, for example `my_nginx_app_&lt;固定metric名>`</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my_nginx_app    <span class="token key atrule">format</span><span class="token punctuation">:</span> '$remote_addr <span class="token punctuation">-</span> $remote_user <span class="token punctuation">[</span>$time_local<span class="token punctuation">]</span> ' '\"$request_uri\" $request_time $status';    <span class="token comment"># 设置所抓取 nignx 服务 logs 具体地址</span>    <span class="token key atrule">source</span><span class="token punctuation">:</span>      <span class="token key atrule">syslog</span><span class="token punctuation">:</span>        <span class="token key atrule">listen_address</span><span class="token punctuation">:</span> <span class="token string">"udp://127.0.0.1:88888"</span>        <span class="token comment"># format 格式代码rfc3164，可查询https://www.diaryfolio.com/2020/07/syslog-standards-simple-comparison.html查看相关</span>        <span class="token key atrule">format</span><span class="token punctuation">:</span> rfc3164        <span class="token key atrule">tags</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> nginx    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> my_nginx_app      <span class="token key atrule">nginx</span><span class="token punctuation">:</span> nginx    <span class="token comment"># relabel的配置</span>    <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>      <span class="token comment"># 对 request_uri 的 path label的内容进行查询替换操作等</span>      <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> path        <span class="token key atrule">from</span><span class="token punctuation">:</span> request_uri        <span class="token key atrule">matches</span><span class="token punctuation">:</span>          <span class="token comment"># 去除 path中 URL 查询参数</span>          <span class="token punctuation">-</span> <span class="token key atrule">regexp</span><span class="token punctuation">:</span> <span class="token string">'^([^?]*)?.*'</span>            <span class="token key atrule">replacement</span><span class="token punctuation">:</span> <span class="token string">'$1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在配置prometheus_nginxlog_exporter时，可能需要将配置文件挂载在某volume上以便于服务启动使用。</p><p>当然这时候还存在一个问题，Nginx服务如何能规律的产生log呢？<br>这就需要引入k8s的liveness和readiness probe监测配置了。</p><p><strong>K8S 容器状态监测</strong></p><blockquote><p>Both liveness &amp; readiness probes are used to control the health of an application. Failing liveness probe will restart the container, whereas failing readiness probe will stop our application from serving traffic.</p></blockquote><p>Refer: <a href="https://medium.com/@AADota/kubernetes-liveness-and-readiness-probes-difference-1b659c369e17">Liveness and Readiness Probes — Difference</a></p><p>至此，一个如何配置Nginx 前端服务的监控数据指标讲解完成。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>正如前言所说，本文仅针对Dev如何配置所开发的服务的以暴露监控指标便于监控平台识别，具体监控平台方如何配置，如何告警不在本文范畴。<br>希望通过本文<strong>讲述如何通过配置Springboot服务和Nginx服务暴露其Metric监控数据接口</strong>，以供Prometheus调用消费。能让读者有所启发或思路进行扩展。<br>当然，本文也只是在结合作者个人使用经验进行整理和记录，奈何作者经验浅薄，又不愿将来有用之时却寻找不到相关资料，故而书写此文。<br>必然文中有些文字不恰当或错误之处，若读者不介意，请一一指出。</p>]]></content>
      
      
      <categories>
          
          <category> Devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prometheus </tag>
            
            <tag> Monitor </tag>
            
            <tag> Metrics </tag>
            
            <tag> Nginx </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Get Started</title>
      <link href="2021/07/30/android-get-started/"/>
      <url>2021/07/30/android-get-started/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-101-从入门之放弃路线"><a href="#Android-101-从入门之放弃路线" class="headerlink" title="Android 101 从入门之放弃路线"></a>Android 101 从入门之放弃路线</h1><p>近来有机会初步学习Android开发的基本要点，虽项目尚不需使用，但正所谓闲来无事，几斤几两的肚中墨水还需增加。<br>脑子总复现武当开派宗师张三丰对其徒孙所说的那几句话。</p><blockquote><p>无忌，你学会了吗？<br>师公，我又忘光了。</p></blockquote><p>因此，本文注重在于整理学习Android过程的基础知识以便日后需要进而勾取当下回忆而不至于又忘光了。<br>从Android 布局 -&gt; 多线程 -&gt; 数据存储 -&gt; 网络 -&gt; 测试 路线徐徐展开。</p><p>当然<br>工欲善其事，必先利其器。</p><ul><li><a href="https://developer.android.com/studio">Android Studio</a></li><li><a href="https://developer.android.com/studio/command-line/adb">Android Debug Bridge</a></li><li><a href="https://developer.android.com/studio/run/managing-avds">AVD manager</a></li></ul><p>若需查看Android-HelloWorld Demo 代码，请 Star <a href="https://github.com/dragonwang-hub/android-helloworld">Demo</a>地址。</p><h2 id="Android-布局"><a href="#Android-布局" class="headerlink" title="Android 布局"></a>Android 布局</h2><p>在学习Android中，还没有接触类似于Web开发的前后端分离开发形式。因此，仍需自己Code 相关前端页面，若有前端微微基础，倒也不算困难。</p><h3 id="常用四种布局"><a href="#常用四种布局" class="headerlink" title="常用四种布局"></a>常用四种布局</h3><ul><li>LinearLayout <a href="https://www.runoob.com/w3cnote/android-tutorial-linearlayout.html">线性布局</a></li><li>RelativeLayout 相对布局： 相对布局 (RelativeLayout) 以 父容器 或者 兄弟组件 参考+margin +padding 来设置组件的显示位置</li><li>FrameLayout  帧布局：屏幕上开辟出一块空白的区域,当往里面添加控件的时候,会默认把他们放到这块区域的左上角。</li><li>ConstraintLayout <a href="https://developer.android.com/training/constraint-layout">约束布局</a>：所有的视图均根据同级视图与父布局之间的关系进行布局</li></ul><p>[文章] <a href="https://blog.csdn.net/qq_40587575/article/details/107484260">常用UI布局和控件</a><br>[文章] <a href="https://guides.codepath.com/android/Working-with-the-ScrollView">ScrollView</a><br>[文章] <a href="https://developer.android.com/training/basics/firstapp/starting-activity">启动另一个 Activity</a><br>[文章] <a href="https://www.tutorialspoint.com/how-to-start-new-activity-on-click-button-in-android">How to start new Activity on click button in Android?</a><br>[文章] <a href="https://stackoverflow.com/questions/19545370/android-how-to-hide-actionbar-on-certain-activities">Hide ActionBar on certain activities</a><br>[文章] <a href="https://developer.android.com/training/system-ui/status">No statusbar</a><br>[文章] <a href="https://android--code.blogspot.com/2015/01/android-rounded-corners-button.html">How to create a rounded corners Button in Android</a><br>[文章] <a href="https://stackoverflow.com/questions/27709238/edittext-change-border-color-with-shape-xml/27709426">Edittext change border color with shape.xml</a><br>[文章] <a href="https://stackoverflow.com/questions/64722733/android-background-drawable-not-working-in-button-since-android-studio-4-1">Android Background Drawable Not Working in Button Since Android Studio 4.1</a></p><h3 id="Acitvity-和-Fragment"><a href="#Acitvity-和-Fragment" class="headerlink" title="Acitvity 和 Fragment"></a>Acitvity 和 Fragment</h3><h4 id="Acitvity"><a href="#Acitvity" class="headerlink" title="Acitvity"></a>Acitvity</h4><p>Activity 是Android<a href="https://juejin.cn/post/6844903977100771335">四大组件</a>之一<br>Activity 中所有操作都与用户密切相关，是一个负责与<strong>用户交互</strong>的组件。</p><p><strong>每个Activity 都需要在AndroidManifest.xml声明。</strong></p><p>两种<a href="https://blog.csdn.net/Blue3Red1/article/details/108903751">启动模式</a>：</p><ul><li>显式启动：直接指定要跳转的Activity类名，不用过滤，效率高，适用于同一个应用中的不同Activity跳转。</li><li>隐式启动：需要过滤，相对耗时，但可以找到所有之匹配的应用。适用于不同应用之间的Activity跳转。</li></ul><p>[文章] <a href="https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn#tba">启动一个Activity</a><br>[文章] <a href="https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn">Activity生命周期</a><br>[文章] <a href="https://developer.android.com/guide/components/activities/state-changes?hl=zh-cn">Activity状态</a><br>[文章] <a href="https://developer.android.com/guide/components/intents-filters?hl=zh-cn#top_of_page">Intent和Intent Filter</a></p><h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p><a href="https://guides.codepath.com/android/creating-and-using-fragments#embedding-a-fragment-in-an-activity">Fragment</a>必须依附于Activity或者另一个Fragment。<br>Fragment 允许您将界面划分为离散的区块，从而将模块化和可重用性引入 Activity 的界面。Activity 是围绕应用的界面放置全局元素（如抽屉式导航栏）的理想位置。相反，Fragment 更适合定义和管理单个屏幕或部分屏幕的界面。</p><ol><li>更像一个轻量级的Activity。更具模块化。</li></ol><p>一般用于一个页面无法显示全部内容或在不同尺寸屏幕用不同布局显示相同内容</p><ul><li>加入backStack，被切换时会处于STOP状态，不会Destory，并且点击返回键还可以回弹出原来Fragment。</li><li>onCreateView()内增加一些方法调用。而不是onCreate()</li></ul><ol start="2"><li>FragmentManager 与 Fragment 的关系</li></ol><ul><li>负责决定fragment应处于的状态，并进行状态更改。</li><li>负责attach或detach一个fragment到其宿主。</li></ul><p>当Fragment被添加至FragmentManager，会调用onAttach方法<br>当Fragment被移除至FragmentManager，会调用onDetach方法<br>onAttach()/onDetach is always called before any Lifecycle state changes.</p><p><strong>生命状态不可能比宿主更高。启动晚于父，销毁早于父</strong></p><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p><a href="https://guides.codepath.com/android/using-the-recyclerview">RecyclerView</a> 会回收这些单个的元素。当列表项滚动出屏幕时，RecyclerView 不会销毁其视图。相反，RecyclerView 会对屏幕上滚动的新列表项重用该视图。这种重用可以显著提高性能，改善应用响应能力并降低功耗。</p><h4 id="三种布局"><a href="#三种布局" class="headerlink" title="三种布局"></a>三种布局</h4><ol><li>LinearLayoutManager 将各个项排列在一维列表中。</li><li>GridLayoutManager 将所有项排列在二维网格中</li><li>StaggeredGridLayoutManager 同一行或同一列中的列表项可能会错落不齐。</li></ol><h4 id="Code-Step"><a href="#Code-Step" class="headerlink" title="Code Step"></a>Code Step</h4><ol><li>构造Activity 存放一个recycler view控件。（包括class,xml）</li><li>声明initRecyclerView(), 实现通过id获取recycler view控件，并对控件设置setAdapter()和setLayoutManager()</li><li>根据第二步，需要自己实现一个Adapter。<br> 3.1. 包括继承RecyclerView.ViewHolder实现一个ViewHolder。ViewHold存放每一个元素的表现形式，比如这个元素有一个textview和一个button,就可以存放在viewholder。<br> 3.2. implement Adapter的三个方法。<ul><li>onCreateViewHolder中需要使用一个item的xml布局文件，内部存放的是一个item的元素。此处注意item内容的高度和宽度，不要是一屏。</li><li>onBindViewHolder是用来设置每个viewholder中的数据，根据position确定。</li><li>getItemCount 返回当前元素列表的长度</li><li>若有必要，还需在adapter类内实现一个setData的方法，用来初始化数据。</li></ul></li><li>返回之Activity class, 在initRecyclerView内构造自定义的adapter，并赋予数据。</li></ol><h2 id="Android-多线程"><a href="#Android-多线程" class="headerlink" title="Android 多线程"></a>Android 多线程</h2><p>对于Android而言，页面就属于主线程，但在应用后台，可能需要其他操作，例如读写文件或者下载文件数据等等，若这些操作在主线程，将会阻塞页面展示效果造成程序不响应等问题，所以在Android中多线程是必须的。</p><p><a href="https://blog.csdn.net/u011240877/article/details/53142177">理解Android多线程</a><br><a href="https://blog.csdn.net/u011240877/article/details/53142177">多线程性能</a><br><a href="https://www.cnblogs.com/BeyondAnyTime/articles/2989239.html">AsyncTask示例</a> Android 11已弃用<br>[HandlerThread](<a href="https://blog.csdn.net/weixin_41101173/article/details/79687313">https://blog.csdn.net/weixin_41101173/article/details/79687313</a> ; <a href="https://www.cnblogs.com/demodashi/p/8481574.html">https://www.cnblogs.com/demodashi/p/8481574.html</a>)</p><p>虽然Android SDK 提供了一些方法用于实现UI线程与后台工作线程的分离，但还有一种更简单的链式调用Library <a href="https://gank.io/post/560e15be2dca930e00da1083">RxJava</a>（<strong>五星推荐</strong>）也可以更好实现多线程操作。</p><p>[文章] <a href="https://www.jianshu.com/p/2a882604bbe8">RxJava 关于 Disposable</a><br>[文章] <a href="http://reactivex.io/documentation/operators.html">RxJava 文档</a></p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>本地数据存储的几种方式</p><ul><li>SP： <a href="https://developer.android.com/training/data-storage/shared-preferences">SharePerference</a> 保存的相对较小键值对集合，每个 <code>SharedPreferences</code> 文件均由框架进行管理，可以是私有文件，也可以是共享文件。</li><li>assert 目录：<a href="https://www.jianshu.com/p/5974fcf88170">Android的一种特殊目录</a>，用于放置APP所需的固定文件，且该文件被打包到APK中时，不会被编码到二进制文件。</li><li>raw 资源：Android一种资源文件，在res目录下。可通过API进行调用，每个raw下的文件都有id。<code>R.raw.id</code><a href="https://www.programcreek.com/java-api-examples/?class=android.content.res.Resources&method=openRawResource">获取当前指定文件</a>。</li></ul><p><strong>Room 数据库</strong></p><p>Android 使用 Sqlite 数据库，<a href="https://developer.android.com/training/data-storage/room">Room</a> 是对 Sqlite 的封装。以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p><p>目的：最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p><p>难点：涉及存取数据的操作，需要定义Dao / Entity / Repository，还需考虑Entity 外键映射关系等等。<a href="https://juejin.cn/post/6844903903020974093">推荐阅读</a></p><p>配置 Room + RxJava 时注意根据 RxJava 的版本配置 </p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy">androidx<span class="token punctuation">.</span>room<span class="token punctuation">:</span>room<span class="token operator">-</span>rxjava3<span class="token punctuation">:</span><span class="token punctuation">$</span>room_version 或者 androidx<span class="token punctuation">.</span>room<span class="token punctuation">:</span>room<span class="token operator">-</span>rxjava2<span class="token punctuation">:</span><span class="token punctuation">$</span>room_version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>[文章] <a href="https://developer.android.com/training/data-storage/room">使用 Room 将数据保存到本地数据库</a><br>[文章] <a href="https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757">Room + RxJava</a><br>[文章] <a href="https://developer.android.com/jetpack/androidx/releases/room">Room 依赖配置</a></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在应用中，权限设置我们经常能看到，实际上，安卓分为<a href="https://developer.android.com/guide/topics/permissions/overview">基本权限和危险权限</a>。而网络属于基本权限中一种，但若需要此权限，仍需要在Manifest.xml<a href="https://developer.android.com/training/permissions/declaring?hl=zh-cn">声明应用权限</a>。<br>Android中可以使用两种框架来获取网络数据，这里主要使用<a href="https://square.github.io/okhttp/">Okhttp Library</a></p><p>[文章] <a href="https://stackoverflow.com/questions/32687921/using-rxjava-and-okhttp">Using RxJava and Okhttp</a></p><p>实际上，在本次101学习过程中，没有过多接触<a href="https://developer.android.com/jetpack/guide">Android架构</a>相关的知识，不像三层架构或者DDD架构模式有所了解，所以Class文件职责划分并不清晰。</p><h4 id="ViewModel-amp-LiveData"><a href="#ViewModel-amp-LiveData" class="headerlink" title="ViewModel &amp; LiveData"></a>ViewModel &amp; LiveData</h4><p>如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。<br>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。<br>LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p><p>[文章] <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData 概览</a><br>[文章] <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel 概览</a></p><p>使用这两个Class可以使数据及时更新和保存，更利于页面数据的实时展示。</p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>测试的目的，并不用多说。</p><p>Android 测试分为单元测试和UI页面测试。</p><p>[文章] <a href="https://developer.android.com/studio/test">Android测试</a><br>[文章] <a href="https://developer.android.com/training/testing/unit-testing/local-unit-tests">构建本地单元测试</a><br>[文章] <a href="https://developer.android.com/training/testing/ui-testing/espresso-testing">测试单个应用界面</a></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>[文章] <a href="https://blog.csdn.net/qq_23062979/article/details/81294550">SDK Version</a><br>[文章] <a href="https://www.jianshu.com/p/c11862136abf">Anroid Gradle Build</a><br>[文章] <a href="https://developer.android.com/training/articles/keystore">Keystore</a><br>[文章] <a href="https://github.com/google/gson/blob/master/UserGuide.md">gson</a><br>[文章] <a href="https://github.com/bumptech/glide">图片加载库 Glide</a><br>[文章] <a href="https://developer.android.com/training/basics/network-ops/connecting">连接到网络</a><br>[文章] <a href="https://www.jianshu.com/p/98324e5d67ae">Android基础之自定义Application</a><br>[文章] <a href="https://developer.android.com/guide/topics/ui/notifiers/toasts">Toast</a></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>在个人学习过程，也遇到不少难于理解的问题，现将其整理如下：</p><ol><li><p>Login页面要考虑各种高度的手机适配问题，有的手机高度不够，可能下面的按钮就看不到了，所以建议在 ConstraintLayout 外部套上 androidx.core.widget.NestedScrollView</p></li><li><p>如果有用到图片资源，需要创建各分辨率的 drawable 目录，要将图片资源放入 drawable 中而不是 mipmap 中.mipmap放启动图标比较合适。</p></li><li><p>如果不配置 keystore， Android studio 会自动配置一个 debug keystore给你的apk，这个debug keystore只能用一年，一年后这个apk就不能再被安装了。</p></li><li><p>设置button透明</p><pre class="line-numbers language-none"><code class="language-none">android:background&#x3D;&quot;@android:color&#x2F;transparent&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>4.1 以上隐藏actionbar和statusbar</p><pre class="line-numbers language-none"><code class="language-none">View decorView &#x3D; getWindow().getDecorView();&#x2F;&#x2F; Hide the status bar.int uiOptions &#x3D; View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);&#x2F;&#x2F; Remember that you shrould never show the action bar if the&#x2F;&#x2F; status bar is hidden, so hide that too if necessary.ActionBar actionBar &#x3D; getActionBar();if (actionBar!&#x3D;null)actionBar.hide();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若发现代码中无法获取actionbar，可在manifest文件配置</p><pre class="line-numbers language-none"><code class="language-none">android:theme&#x3D;&quot;@style&#x2F;Theme.AppCompat.Light.NoActionBar&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可应用在全局或指定某个activity内。<br>若是继承AppCompatActivity，则只需加入一条语句：</p><pre class="line-numbers language-none"><code class="language-none">getSupportActionBar().hide();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>FrameLayout布局的特点是：所有放在布局里的视图组件，都按照层次堆叠在屏幕的左上角，后面的视图组件覆盖前面的。 当然，组件本身是可以控制自己的内部布局的。 一种常见的场景是可以在FrameLayout上放多个图片视图，来实现动画。</p></li><li><p>Android 项目 数据文件存放位置在 asset，与java/res同层级<br><a href="https://blog.csdn.net/ww897532167/article/details/70875334">https://blog.csdn.net/ww897532167/article/details/70875334</a></p></li><li><p>Textview设置多行</p></li></ol><ul><li>Android:singleLine=”true”，单行：</li><li>android:lines=”2”<br>android:ellipsize=”end”</li></ul><p>这样就可以让TextView最多显示2行，如果要显示指定的其它行数，只要修改上面的android:lines属性即可，设置了显示两行，如果内容用一行就可以全部显示了，这时候TextView会占用两行的高度空间。</p><ul><li>android:maxLines=”2”<br>android:ellipsize=”end”<br>显示两行，高度自适应</li></ul><ol start="9"><li>自定义实现recyclerview的headerview和footerview<br><a href="https://www.jianshu.com/p/e9dfb7167f87">https://www.jianshu.com/p/e9dfb7167f87</a><br><a href="https://www.journaldev.com/12372/android-recyclerview-example">https://www.journaldev.com/12372/android-recyclerview-example</a></li><li>判断当前recyclerview的item是最后一个position<br><a href="https://blog.csdn.net/salute_li/article/details/52118504">https://blog.csdn.net/salute_li/article/details/52118504</a></li><li>collection Type 示例 （序列化与反序列化）<br>Type listUserType = new TypeToken&lt;List<User>&gt;() { }.getType();</li><li>Activity 和 Context 的区别与联系：<br><a href="https://blog.csdn.net/weixin_41101173/article/details/79882846">https://blog.csdn.net/weixin_41101173/article/details/79882846</a></li><li>new ViewModelProvider(this)中this报错<br><a href="https://blog.csdn.net/zsq8187/article/details/109087798">https://blog.csdn.net/zsq8187/article/details/109087798</a></li><li>ViewModel &amp; AndroidViewModel 适用<br>如果 ViewModel 需要 Application 上下文（例如，为了查找系统服务），它可以扩展 AndroidViewModel 类并设置用于接收 Application 的构造函数，因为 Application 类会扩展 Context。</li><li>Test Error<br>Error: “Method … not mocked”<br>如果您运行测试，从Android SDK调用API，你不会使用mock，可能会收到一个错误，说这种方法没有被模拟。 这是因为用于运行单元测试的android.jar文件不包含任何当前代码（这些API仅由设备上的Android系统映像提供）。</li></ol><p>相反，所有方法默认都会抛出异常。 这是为了确保你的单元测试你的代码，而不是依赖于Android平台的任何特定的行为（你没有明确地mock，如Mockito）。</p><p>如果抛出的异常说你的测试有问题，可以更改行为，以便通过在项目的顶级build.gradle文件中添加以下配置来返回null或零：</p><pre class="line-numbers language-none"><code class="language-none">android &#123;  ...  testOptions &#123;    unitTests.returnDefaultValues &#x3D; true  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：将returnDefaultValues属性设置为true应该小心。 null / zero返回值可以在测试中引入回归，这些回调很难调试，并且可能允许失败的测试通过。只能用它作为最后的手段。</p><p><strong>路漫漫其修远兮，吾将上下而求索。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
            <tag> Rxjava </tag>
            
            <tag> Layout/ViewModel/LiveData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin POJO 101(2)</title>
      <link href="2021/06/20/kotlin-pojo-101-2/"/>
      <url>2021/06/20/kotlin-pojo-101-2/</url>
      
        <content type="html"><![CDATA[<h2 id="object-companion-object"><a href="#object-companion-object" class="headerlink" title="object / companion object"></a>object / companion object</h2><p>object是Kotlin中的一个重要的关键字。</p><p>java 全局静态类 <code>static class GlobalUse</code><br>kotlin没有<code>static</code>关键字，但有<code>object</code>关键字。</p><h3 id="object声明对象"><a href="#object声明对象" class="headerlink" title="object声明对象"></a>object声明对象</h3><p>使用object可以在kotlin中实现单例模式。也可以理解为全局静态类。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">object</span> OutObject <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> outParameter <span class="token operator">=</span> <span class="token string">"out"</span>    <span class="token keyword">fun</span> <span class="token function">outFunction</span><span class="token punctuation">(</span>parameter<span class="token operator">:</span>String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Out object function result: <span class="token interpolation variable">$parameter</span>."</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fun</span> <span class="token function">changeParam</span><span class="token punctuation">(</span>parameter<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    OutObject<span class="token punctuation">.</span>outParameter <span class="token operator">=</span> parameter<span class="token punctuation">&#125;</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>OutObject<span class="token punctuation">.</span>outParameter<span class="token punctuation">)</span>    OutObject<span class="token punctuation">.</span><span class="token function">outFunction</span><span class="token punctuation">(</span><span class="token string">"Test object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"==========================\n"</span><span class="token punctuation">)</span>    <span class="token function">changeParam</span><span class="token punctuation">(</span><span class="token string">"change param"</span><span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span>OutObject<span class="token punctuation">.</span>outParameter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>object declaration的类最终被编译成：一个类拥有<strong>一个静态成员来持有对自己的引用，并且这个静态成员的名称为INSTANCE</strong>。</p><p>注：和普通类的声明一样，可以包含属性(props)、方法(methods)、初始化代码块(init)以及可以继承其他类或者实现某个接口(:)，但**不能包含构造器(constructor)**。</p><p>object 也可以用于一个内部类的声明。与外部声明无区别，也属于内部类的单例模式。当然，内部类还有其他一些玩法，我们之后再进行了解（inner）</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> ObjectOuter <span class="token punctuation">&#123;</span>    <span class="token keyword">object</span> Inner<span class="token punctuation">&#123;</span>        <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm in inner class"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ObjectOuter<span class="token punctuation">.</span>Inner<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="companion-object-伴生对象"><a href="#companion-object-伴生对象" class="headerlink" title="companion object 伴生对象"></a>companion object 伴生对象</h3><p>因为在kotlin中没有static关键字的，就没有静态方法和静态成员。<br>因此在kotlin中使用包级别函数(package-level function)和伴生对象。</p><p>简单说一下包级别函数：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token keyword">fun</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello <span class="token interpolation variable">$name</span>!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// import method</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>sayHello<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果采用伴生对象实现静态方法，就需要使用<code>companion object</code></p><p>示例如下：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> ObjectTest <span class="token punctuation">&#123;</span>   <span class="token comment">// 定义时如果省略了伴生对象名，那么编译器会为其提供默认的名字Companion</span>  <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//companion object MyObjec&#123;</span>        <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">20</span>        <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm in companion object"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 如此调用，则与调用静态方法一致。</span>    ObjectTest<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>ObjectTest<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态方法调用成员变量，要求成员变量必须是<code>静态的</code></p><p>实际上，object可以用于对象表达式来声明匿名类。但需要注意：</p><ul><li>匿名对象只有<strong>定义成局部变量和private成员变量</strong>时，才能体现它的真实类型(才能被访问)。</li><li>如果你是将匿名对象作为public函数的返回值或者是public属性时，你只能将它看做是它的父类，当然你不指定任何类型时就当做Any看待。这时，你在匿名对象中添加的属性和方法是<strong>不能够被访问的</strong>。</li></ul><p>未曾使用过，不做具体分析，若有需求，可自行查看。</p><h2 id=""><a href="#" class="headerlink" title="?"></a>?</h2><blockquote><p>Kotlin’s type system is aimed at eliminating the danger of null references from code, also known as the <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">The Billion Dollar Mistake</a>.</p></blockquote><p><strong>目的就在于淘汰空指针（NPE）情况。</strong></p><h3 id="含义"><a href="#含义" class="headerlink" title="?含义"></a>?含义</h3><p>因此，在声明类型时，自动类型推导可以区分可空（null）和不可空（non-null）。</p><p>在变量声明后加 ? 可允许变量为null。</p><p>比如：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> strA<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"abc"</span>strA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">// error : Null can not be a value of a non-null type String</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若是声明可为null的变量，可使用 <strong>?</strong> </p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> strB<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"ab"</span>strB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token comment">// correct.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是，因为使用了? 会引发一些问题。比如无法安全调用对象的方法与属性。即当对象为null时，其不可能去调用属性方法。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">strA<span class="token punctuation">.</span>length <span class="token comment">// correct</span>strB<span class="token punctuation">.</span>length <span class="token comment">// incorrent. error: variable 'b' can be null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>as</code> 作为类型转换关键字，<code>?</code>与<code>as</code>可结合使用。<br><code>as?</code>表示若可以转换为指定类型则转换，若不行，返回null。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string">"adf"</span><span class="token keyword">val</span> math <span class="token operator">=</span> str <span class="token keyword">as</span> Int <span class="token comment">// ClassCastException</span><span class="token keyword">val</span> math <span class="token operator">=</span> str <span class="token keyword">as</span><span class="token operator">?</span> Int <span class="token comment">// return null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="-1"><a href="#-1" class="headerlink" title="?."></a>?.</h3><p>因此，当你声明了可空变量，就需要采取一些方法来规避上述问题。<br>也许第一念头法是使用条件判断去处理null和非null的情况。但是，若用Conditions会使程序更冗长。</p><p><em>写到这里，突然发现，Java的Optional与其有异曲同工之妙。</em></p><p>因此，kotlin提供了一种safe calls的运算法 <strong>?.</strong> 用于对可空变量的调用。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">strB<span class="token operator">?</span><span class="token punctuation">.</span>length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实， <strong>?.</strong> 在链式调用中优势最明显，若其中有null存在，结果为null。不需要多层判断。（Js也有?. 用于避免相同情况）</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> company<span class="token operator">?</span><span class="token punctuation">.</span>unit<span class="token operator">?</span><span class="token punctuation">.</span>manager<span class="token operator">?</span><span class="token punctuation">.</span>firstName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>补充一点关于 Scope functions的知识。具体了解可参考<a href="https://juejin.cn/post/6892176970965057550">此文</a>。</em></p><p>将<code>?.</code>与<code>let</code>结合使用，将为null的对象全部过滤并执行<code>let</code>内的代码。类似的还有<code>run</code>,<code>apply</code>等。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> listWithNulls<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> listWithNulls<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    item<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">&#123;</span>         <span class="token keyword">val</span> count <span class="token operator">=</span> it <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// it 关键字，替代对象</span>         <span class="token function">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如此便将null值过滤出let执行块内。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="-2"><a href="#-2" class="headerlink" title="?:"></a>?:</h3><p>当使用可空声明<code>?</code>之后，如何对null情况进行抉择呢？如果使用<code>if else</code>这类条件判断会显得代码过于冗长。kotlin提供<code>?:</code>运算符解决此类问题。<br>若<code>?:</code>左边表达为null，则会执行其右边表达式，否则，返回左边表达式的值。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> strC<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"ccc"</span><span class="token keyword">val</span> stcD<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">val</span> lenC <span class="token operator">=</span> strC<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token operator">?:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// return 3</span><span class="token keyword">val</span> lenD <span class="token operator">=</span> strD<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token operator">?:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// return -1</span><span class="token keyword">val</span> lenD <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>strD<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> strD<span class="token punctuation">.</span>length <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：右边也可以是throw语句。</p><h3 id="-3"><a href="#-3" class="headerlink" title="!!"></a>!!</h3><p>有时候如果需要将nullable变量转换为non-nullable变量，则需要用上<code>!!</code>强制类型转换符。<br>同时也要注意，一旦变量被声明为non-nullable类型，若出现为null情况，就会出现NPE。<br>因此，不要随意使用<code>!!</code></p><p>这部分内容先到此为止，若有后续需求，会继续更新。江湖路远，不见不散。</p>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> POJO </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> NPE/?. </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin POJO 101(1)</title>
      <link href="2021/05/25/kotlin-pojo-101/"/>
      <url>2021/05/25/kotlin-pojo-101/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-POJO-1"><a href="#Kotlin-POJO-1" class="headerlink" title="Kotlin POJO (1)"></a>Kotlin POJO (1)</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><strong>var/val</strong></p><ul><li>var: variable. 声明一个变量。在初始赋值会后仍然可以再被重新赋值，变量类型可自动推导</li><li>val: value. 声明一个不可变的变量。在初始赋值之后就再也不能重新赋值，类似于Java中的final变量；</li></ul><p>永远优先使用val来声明一个变量，而当val没有办法满足你的需求时再使用var。（这是一种没有变量的思想。）</p><p>注意： 变量类型推导在赋予初始值完成，若要采用延迟赋值，Kotlin则无法推导其类型，仍需要显式声明类型。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> name name <span class="token operator">=</span> <span class="token string">"DDD"</span><span class="token comment">// This variable must either have a type annotation or be initialized</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"DDD"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Kotlin没有基本类型，全部使用对象类型<br><code>Int, String, Long, Double Boolean ......</code><br>类似于Java中包装基本类型的，包装类型。</p><p><strong>const</strong></p><p>若是声明常量：使用const关键字，const不能与var配合使用。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">const</span> <span class="token keyword">val</span> ITS_NAME <span class="token operator">=</span> <span class="token string">"Name IT"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>final</strong></p><p>请注意，kotlin中默认的类和方法都是final的。因此不能继承、不能override。<br>若要实现可继承的基类需要使用<strong>open关键字</strong>。<br>继承父类与实现接口都只使用<code>:</code>即可。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> Parent <span class="token punctuation">&#123;</span>    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> Child <span class="token operator">:</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>主构造函数/次构造函数</strong></p><p>在 Kotlin 中的一个类可以有一个<strong>主构造函数</strong>以及一个或多个<strong>次构造函数</strong>。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Person <span class="token keyword">constructor</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*……*/</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <em>constructor</em> 关键字。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*……*/</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果子类有主构造函数， 则基类必须在子类主构造函数中立即初始化。</li><li>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</li><li>通过在一个类中使用主和次级构造函数，次级构造函数需要授权给主构造函数,也就是<strong>次级构造函数会直接或者间接调用主构造函数</strong>。</li></ul><p>示例对比Kotlin/Java 继承及构造器</p><p>// kotlin</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token string">"DAD"</span><span class="token punctuation">)</span>    parent<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token string">"SON"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    child<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> secondChild <span class="token operator">=</span> <span class="token function">SecondChild</span><span class="token punctuation">(</span><span class="token string">"SEC"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>    secondChild<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"I am Parent. My name is:<span class="token interpolation variable">$name</span>\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"I am Child. My name is:<span class="token interpolation variable">$name</span> I am<span class="token interpolation variable">$age</span>\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> SecondChild <span class="token operator">:</span> Parent <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> age<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">javaDemo</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> main <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Parent</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">"DAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        parent<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Child</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"SON"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        child<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Parent. My name is:"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Child. My name is:"</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" I am"</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">".\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>无参构造函数</strong></p><p>kotlin中 不管是class 还是data class 都不会自动帮你生成 无参的构造函数。</p><ul><li><p>把定义的属性 <strong>手动给他指定一个默认值</strong></p></li><li><p>声明<strong>指定一个无参的构造函数</strong></p></li><li><p><strong>注解</strong>实现无参构造器</p></li></ul><p>Demo: 使用@NoArg</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">// build.gradle.kts</span>noArg <span class="token punctuation">&#123;</span>    <span class="token keyword">annotation</span><span class="token punctuation">(</span><span class="token string">"statuspage.backend.annotation.NoArg"</span><span class="token punctuation">)</span>    invokeInitializers <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token comment">// annoation</span><span class="token keyword">package</span> noarg<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>annotation<span class="token keyword">annotation</span> <span class="token keyword">class</span> NoArg<span class="token comment">// how to use</span><span class="token annotation builtin">@NoArg</span><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">OrgInfo</span><span class="token punctuation">(</span>    <span class="token keyword">val</span> orgName<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> Serializable<span class="token comment">// how to use no-arg create object</span><span class="token keyword">val</span> orgInfo <span class="token operator">=</span> OrgInfo<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="data-class"><a href="#data-class" class="headerlink" title="data class"></a>data class</h2><p><strong>只保存数据</strong>的类</p><p>在Kotlin中，不能从数据类继承，因为编译器没有明智的方法来生成为数据类自动提供的所有方法。</p><p>data 数据类底层实现了哪些基本方法</p><ul><li>getter/setter</li><li>全参构造器</li><li>equals()/hashCode()</li><li>toString</li><li>copy() : 浅拷贝</li><li>componentN() : 按声明顺序对应于所有属性</li></ul><p>数据类必须满足以下要求：</p><ul><li>主构造函数需要至少有一个参数；</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li><li>数据类不能是抽象、开放、密封或者内部的；</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@NoArg</span><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Info</span><span class="token punctuation">(</span>    <span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">,</span>    <span class="token keyword">val</span> panelId<span class="token operator">:</span> Int<span class="token punctuation">,</span>    <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span>    <span class="token keyword">val</span> state<span class="token operator">:</span> String<span class="token punctuation">,</span>    <span class="token keyword">val</span> newStateDate<span class="token operator">:</span> Date<span class="token punctuation">,</span>    <span class="token keyword">val</span> url<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> Serializable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注： data class依然没有无参构造器，实现无参构造与上述方法相似。</p>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
            <tag> POJO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean-Code之注释</title>
      <link href="2021/05/23/clean-code-zhi-zhu-shi/"/>
      <url>2021/05/23/clean-code-zhi-zhu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Clean-Code之注释"><a href="#Clean-Code之注释" class="headerlink" title="Clean Code之注释"></a>Clean Code之注释</h1><p>在很多源码中，注释常常与代码相伴而行。有的作为作者信息声明，有的作为程序逻辑解读，有的作为更改时间记录。或多或少都是留下注释的痕迹。<br>在初学编程之际，一把梭的编程手法，总是会让观者无法理解具体含义，往往就采用了注释的方法在各行各处声明所书写代码的含义。</p><h2 id="为什么要用注释"><a href="#为什么要用注释" class="headerlink" title="为什么要用注释"></a>为什么要用注释</h2><p>随着渐渐地深入学习，也听到那句“代码即注释”的名言。相信大部分读者都听过这么一句。<br>那么注释是否是真的就没有必要性呢？我们可以看下下面这段关于公平锁和非公平锁实现源码中的核心差异代码。不能说有注释就好，但确实使读者对代码的理解更加容易。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// The correctness of this depends on head being initialized</span>    <span class="token comment">// before tail and on head.next being accurate if the current</span>    <span class="token comment">// thread is first in queue.</span>    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// Read fields in reverse initialization order</span>    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果能把<code>t</code>,<code>h</code>,<code>s</code>赋予合适有意义的命名，或者这段代码就可以删减其注释。关于如何更好的命名，读者可查看第一集内容“Clean Code之命名”。</p><p>好的注释必然有用，但往往注释会乱七八糟，会随着时间变得失效、错误。<br>所以，我们更该用尽心思去编写好的代码，以保证无需编写多余的注释。</p><blockquote><p>若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释——也许根本不需要。</p><p>在程序中，代码是唯一真正准确的表达信息来源。只有代码能忠实的告诉你它做的事。</p></blockquote><p>如果说到为什么要写注释的原由？有时，代码不足以解释其自身的行为，则需要注释进行补充说明。比如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// check to see if the employee is eligible for full benefits</span><span class="token keyword">if</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> HOURLY_FLAG<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">65</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是，若是使用代码也可达成同样的效果，解释代码的意图。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">isEligibleForFullBenefits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>写注释的常见动机之一是糟糕的代码的存在，编写模块后发现代码并不能清晰让人理解其所做所为，因此才需要注释来解释并不尽人意的代码。</p></blockquote><p>本文结合《Clean Code》注释章节和《Alibaba Java 开发手册》部分内容，总结书写注释常见问题及何为好注释。</p><h2 id="什么是坏注释"><a href="#什么是坏注释" class="headerlink" title="什么是坏注释"></a>什么是坏注释</h2><p>如上所述，坏注释常常会出现我们并不在意的地点。比如：毫无意义的注释、因时间太久已经失效的注释、用于记录更新的注释、为了注释而注释的注释等等。<br>本节对常见坏注释进行总结，以警示坏注释出现的场合。</p><ol><li><strong>毫无作用的注释</strong>：比如所书写的注释并<strong>不能提供比代码本身更多的信息</strong>；亦或者注释表述不清晰，更多只是为了提醒书写者自身；亦或者本身注释就是为了注释而已。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 例如：以下注释毫无作用</span><span class="token comment">// logger name</span><span class="token keyword">protected</span> <span class="token class-name">String</span> logName <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// default constructor</span><span class="token keyword">protected</span> <span class="token class-name">AnnualDataRule</span>  <span class="token comment">//</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">// this comment is used to remind me to implement handle exception if necessary</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li> <strong>误导性注释</strong>：其实很多时候，由于需求变更或者产品迭代升级导致代码被大幅修改，而在之前遗留的注释却没有同步更新或删除，那么<strong>遗留的注释</strong>会产生误导性作用导致读者无法理解<strong>代码与注释思想不对等</strong>的情况。这种时常发生，所以，读者应当注意，若无法书写准确无误的注释并及时更新，应主动避免书写注释的现象。</li><li><strong>为了注释而注释的注释</strong>：代码中本<strong>不需对每个变量和方法都书写注释</strong>，例如有些要求每个函数都要有Javadoc，这只会使程序更加难以阅读。也许你也曾遇到类似于<strong>日志型注释</strong>或者用于<strong>归属与署名的注释</strong>，即每次有同事更新此段代码时，都会在代码内部添加一条注释记录此次修改的人员和内容，这也许在上古时代还有一定必要性，现在的程序已经使用了源码版本控制系统（比如git、svn），因此现在不再需要这样的注释。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// user name</span><span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span><span class="token comment">// user age</span><span class="token keyword">private</span> <span class="token class-name">String</span> userAge<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li> <strong>括号后的注释</strong>：有时候，当函数过长时，为了更清楚显眼的找到代码块的结尾，会使用在右括号后增加代码注释的形式，比如<code>// if 、 // while</code>等待形式。那么当出现这类情况时，应当如何呢？当时<strong>思考如何书写更优雅的函数</strong>，让每个函数都更有意义。若不懂如何更好的书写函数，可查看本系列第二季“Clean Code之函数”。</li><li> <strong>注释掉的代码</strong>：不需保留，请删除请删除请删除。</li><li> <strong>与代码无关的注释</strong>：比如注释与函数毫无干系，并未描述当前函数，可能描述的是整个业务模块。或者注释描述及其不清晰，仍需细读代码结合注释才能理解业务。</li><li> <strong>函数头的注释</strong>：当你需要为一个函数头书写注释的时候，你更应该思考，如何为只做一件事的函数书写一个更优雅的名字。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// get user name</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">gun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也许读者会纳闷，为什么直接先讲些坏注释的示例呢？<br>当你看到以上总结时，你会或多或少看到自己曾经的影子，比如作者曾经常书写括号后的注释，并且很少删除注释掉的代码。那么通过反思自身就会更感受到好注释的优点。</p><h2 id="什么是好注释"><a href="#什么是好注释" class="headerlink" title="什么是好注释"></a>什么是好注释</h2><p>了解了以上几类坏注释出现的场景，我们一起看看《Clean Code》中对好注释的场景总结。<br>好的注释必然首先是有意义的，值得去书写的。</p><blockquote><p>唯一真正好的做法仍旧是想方设法不书写注释。</p></blockquote><ol><li><strong>法律信息相关注释</strong>：有时，为保证权益，需要书写法律相关的注释。其不需将具体法律条律内容书写出来，只将注释内容指向标准许可或其他外部文档即可。</li><li><strong>解释性注释</strong>：不仅将难以理解的内容翻译成某种可读的形式，还对此代码实现的意图进行解释。这样的注释更易让读者清晰明确书写者的目的和起因。但也不是必要的。</li><li><strong>用于警示或放大作用的注释</strong>：当代码对系统极其重要，可设立警示型代码提示代码改动可能出现的结果是有必要性的，或者用注释去放大这部分代码的重要性也是可性的。</li><li><strong>TODO注释</strong>：常见的注释，定期查看，删除不需要的即可。</li></ol><p>经过简单的分析，我们其实也可以发现，非必要情况，一定一定不要使用注释是十分重要的。注释并不能美化糟糕的代码。所以，我们在编写代码时，更应考虑的是如何减少注释量，保证“代码即注释”。</p><blockquote><p>什么也比不上放置良好的注释来得有用。什么也不会比乱七八糟的注释更有本事捣乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。</p></blockquote><p>希望本文可以提示读者，从现在开始，反思之前的坏注释，考虑之后相同场景如何避免注释，为书写好的注释做好理论基础。</p><p><strong>Reference</strong></p><ol><li><p>《Clean Code》</p></li><li><p>《Java 开发手册》：<a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf">https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Java </tag>
            
            <tag> 代码整洁/规范 </tag>
            
            <tag> 注释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 Minutes To Get Started React-Redux</title>
      <link href="2021/05/21/react-redux-get-started/"/>
      <url>2021/05/21/react-redux-get-started/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Minutes-To-Get-Started-React-Redux"><a href="#10-Minutes-To-Get-Started-React-Redux" class="headerlink" title="10 Minutes To Get Started React-Redux"></a>10 Minutes To Get Started React-Redux</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Let’s start with a question. Why we need to use Redux?</p><p>We can look at the picture below firstly. The picture shows the communication between components.</p><p>Without redux, if communication is required between two components that have non-parent-child relationships, multiple middle components may be required to deliver messages for them, which wastes resources and makes the code more complex.</p><p>Look at the right part, Using Redux to manage the global state <strong>make it easier</strong> to update the state in your application. Redux can help you manage “global” state - The state that is needed across many parts of your application.</p><img src="/2021/05/21/react-redux-get-started/comminication-between-components.png" class="" alt="comminication-between-components"><p>What is Redux? Redux is a pattern and library for managing and updating application state, using events called “actions”.  Look at this picture. Redux proposes a single data source, <code>Store</code>, which is used to store the global state data. Components can modify state via <code>Action</code>, and fetch the latest state from the Store. Redux is the perfect solution to the communication problem between components.</p><img src="/2021/05/21/react-redux-get-started/image-20210512222346197.png" class="" alt="What is Redux?"><blockquote><p>After understanding what Redux can be used for, we will know applicable scenarios of Redux. That is Multiple components need to share and use the same state.</p></blockquote><h2 id="Basic-terminology"><a href="#Basic-terminology" class="headerlink" title="Basic terminology"></a>Basic terminology</h2><p>To better understand the <code>Redux Application Data Flow</code>, we need to understand some basic terminology.</p><ul><li>Actions  : <strong>You can think of an action as an event that describes something that happened in the application</strong>. In the app code, its manifestation is an object.</li><li>Action Creators  : In the app code, It is the <strong>function used for creating the action object.</strong></li><li>Reducers  : <strong>You can think of a reducer as an event listener which handles events based on the received action (event) type.</strong></li><li>Store : It can be thought of a <strong>global state object</strong> and used to store state data.</li><li>Dispatch  : <strong>You can think of dispatching actions as “triggering an event”</strong>. The Redux store has a method called <code>dispatch</code>.  This is also the default property for higher-level components wrapped with <code>connect</code>.</li></ul><p>Now, we can look at the data flow of redux application together.</p><p>For the initial setup, there are three steps.  The first step is to create a Redux store using a root reducer function. Then the store saves the return value as the root reducer initial state. Next the UI starts the first render,  UI components access the current state of the Redux store and use that data to decide what to render.</p><p>For the update process, there are five steps. Firstly, some events happen in the UI. Such as the click action. Then, the app code dispatches an action to the Redux store. Next, The store runs the reducer function again with the previous state and the current action and saves the new state. Then, the store notifies all parts of the UI that are subscribed to that the store has been updated. Finally, each UI component that the state has changed forces a re-render with the new state, so it can update UI.</p><img src="/2021/05/21/react-redux-get-started/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" class="" alt="ReduxDataFlowDiagram"><p>Next part we’ll introduce the redux component structure and how to quickly use redux in your application.</p><hr><p>When you use react-redux. You need to build the <code>Store</code>, <code>Reducer</code>, <code>Action</code> , and so on.</p><p>But before we talk about how to code these modules, we are better to understand what are UI/Container components on the <code>react-redux application</code>.</p><h2 id="UI-Container-Components-layer-structure"><a href="#UI-Container-Components-layer-structure" class="headerlink" title="UI/Container Components layer structure"></a>UI/Container Components layer structure</h2><ul><li>UI components are concerned with <em><strong>how things look</strong></em>.</li><li>Container components are concerned with <em><strong>how things work</strong></em>.</li></ul><p>Most of the components should be presentational, but if need to use global state,  a few container components are needed to connect them to the Redux store.</p><p>We can look at the comparison table about UI and Container components.</p><table><thead><tr><th align="left"></th><th align="left">UI Components</th><th>Container Components</th></tr></thead><tbody><tr><td align="left">Function</td><td align="left">How things look（Frame、Style）</td><td>How things work（Fetch data、Update state）</td></tr><tr><td align="left">Use Redux directly</td><td align="left">No</td><td>Yes</td></tr><tr><td align="left">Data  from</td><td align="left">props</td><td>Redux state (Store)</td></tr><tr><td align="left">How  update state</td><td align="left">props.func</td><td>Redux dispatch actions</td></tr></tbody></table><h2 id="How-To-Build-Container-Components"><a href="#How-To-Build-Container-Components" class="headerlink" title="How To Build Container Components"></a>How To Build Container Components</h2><p><strong>Connect</strong> </p><p>On the <code>react-redux application</code>, we can use <code>connect()</code>  function to build the UI component as the container component.</p><p>The <code>connect()</code> function connects a React component to the Redux store. It provides its connected component with the data it needs from the store, and the functions it can use to dispatch actions to the store.</p><p>Next, I would introduce two core param on the connect function.</p><p><strong>mapStateToProps</strong></p><p>As the first param passed in to <code>connect</code>, <code>mapStateToProps</code> is used for selecting the part of the data from the store that the connected component needs. </p><blockquote><p>It’s frequently referred to as just <code>mapState</code> for short.</p></blockquote><ul><li>It is called every time the store state changes.</li><li>It receives the entire store state, and should return an object of data this component needs.</li></ul><p>In one sentence, <code>mapStateToProps</code>  is used for mapping states in redux to props of UI components for synchronous updates.</p><p><strong>mapDispatchToProps</strong>  </p><p>As the second param passed in to <code>connect</code>, <code>mapDispatchToProps</code> is used for dispatching actions to the store.</p><p>Providing a <code>mapDispatchToProps</code> allows you to specify which actions your component might need to dispatch. It lets you provide action dispatching functions as props.</p><p>Dispatch the UI Component action to the store, then update the state according to the reducer rules.</p><blockquote><p>Actually, the <code>react-redux</code> already update the hook function following react update.</p><ul><li>useSelector() [Fetch store state]:Allows you to extract data from the Redux store state.</li><li>useDispatch() [Dispatch action]</li></ul><p>It is more convenient, but still has learned new concepts about <code>Slice</code>.</p><p><em>Note: Building <code>Store</code> also is complex. But for a simple project, you can use the<code>Redux Toolkit</code> tool.</em></p></blockquote><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>For using <code>react-redux</code>, there are five main steps:</p><ol><li>createStore() / configureStore() -&gt; Create the <code>Store</code> for store global states.</li><li>Provider -&gt; Set Store to be available within all components.</li><li>Actions(Action Creators)/Reducers -&gt; Set initial state and update policy</li><li>connect() -&gt; Upgrade UI components to container components.</li><li>mapStateToProps/mapDispatchToProps -&gt;  Implementing data mapping, and action dispatching.</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Specific source code : Github Link: <a href="https://github.com/dragonwang-hub/react-redux-counter-demo">Counter Demo Example</a></p><p>Understood these concepts and functions, we can look at a demo about the <code>react-redux</code>.</p><p>Firstly, look at Counter UI and Container. The UI component just shows how things look. It has some props that are mapped from states of redux <code>Store</code>. The container component connects the Redux and implements how things work.</p><p>If we are not using redux, the count is just a property of the counter component. But if we were to store count as a global variable using redux, count is the state in the <code>Store</code> of redux, only the counter is using this state.</p><p><strong>UI Comopoent</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useState <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">"prop-types"</span><span class="token punctuation">;</span><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">"./Counter.module.css"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> count<span class="token punctuation">,</span> increment<span class="token punctuation">,</span> decrement<span class="token punctuation">,</span> incrementByAmount <span class="token punctuation">&#125;</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>  <span class="token operator">...</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token comment">// UI element</span>    <span class="token operator">...</span>    <span class="token operator">...</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Counter<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  count<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>number<span class="token punctuation">,</span>  increment<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span>  decrement<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span>  incrementByAmount<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Counter<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function-variable function">decrement</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function-variable function">incrementByAmount</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Counter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Container Component</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> connect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"react-redux"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Counter <span class="token keyword">from</span> <span class="token string">"./Counter"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> actions <span class="token keyword">from</span> <span class="token string">"../redux/action"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">dispatch</span><span class="token punctuation">(</span>actions<span class="token punctuation">.</span><span class="token function">incrementValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">decrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">dispatch</span><span class="token punctuation">(</span>actions<span class="token punctuation">.</span><span class="token function">decrementValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">incrementByAmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">incrementValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">dispatch</span><span class="token punctuation">(</span>actions<span class="token punctuation">.</span><span class="token function">incrementByAmount</span><span class="token punctuation">(</span>incrementValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  count<span class="token operator">:</span> state<span class="token punctuation">.</span>counter<span class="token punctuation">.</span>count<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token function-variable function">mapDispatchToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  increment<span class="token operator">:</span> <span class="token function">increment</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span>  decrement<span class="token operator">:</span> <span class="token function">decrement</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span>  incrementByAmount<span class="token operator">:</span> <span class="token function">incrementByAmount</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span><span class="token punctuation">(</span>Counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then look at the file structure of redux. There are <code>store</code>,<code>reducer</code>,<code>action</code>,<code>actionType</code>. </p><p><strong>Store</strong></p><p>Use the <code>@reduxjs/toolkit</code> make it easier create the <code>Store</code>.</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> configureStore <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"@reduxjs/toolkit"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> counterReducer <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./reducer"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">configureStore</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  reducer<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    counter<span class="token operator">:</span> counterReducer<span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Reducer</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> actionTypes <span class="token keyword">from</span> <span class="token string">"./actionType"</span><span class="token punctuation">;</span><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">&#123;</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">counterReducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> initialState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> actionTypes<span class="token punctuation">.</span><span class="token constant">INCREMENT_VALUE</span><span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span>state<span class="token punctuation">,</span>        count<span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> actionTypes<span class="token punctuation">.</span><span class="token constant">DECREMENT_VALUE</span><span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span>state<span class="token punctuation">,</span>        count<span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> actionTypes<span class="token punctuation">.</span><span class="token constant">INCREMENT_BY_AMOUNT</span><span class="token operator">:</span>      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span>state<span class="token punctuation">,</span>        count<span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>      <span class="token keyword">return</span> state<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Action</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> actionTypes <span class="token keyword">from</span> <span class="token string">"./actionType"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">incrementValue</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  type<span class="token operator">:</span> actionTypes<span class="token punctuation">.</span><span class="token constant">INCREMENT_VALUE</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">decrementValue</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  type<span class="token operator">:</span> actionTypes<span class="token punctuation">.</span><span class="token constant">DECREMENT_VALUE</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">incrementByAmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">amount</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  type<span class="token operator">:</span> actionTypes<span class="token punctuation">.</span><span class="token constant">INCREMENT_BY_AMOUNT</span><span class="token punctuation">,</span>  payload<span class="token operator">:</span> amount<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">INCREMENT_VALUE</span> <span class="token operator">=</span> <span class="token string">"INCREMENT_VALUE"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">DECREMENT_VALUE</span> <span class="token operator">=</span> <span class="token string">"DECREMENT_VALUE"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">INCREMENT_BY_AMOUNT</span> <span class="token operator">=</span> <span class="token string">"INCREMENT_BY_AMOUBT"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Index.js</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'./index.css'</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> store <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./redux/store'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Provider <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> serviceWorker <span class="token keyword">from</span> <span class="token string">'./serviceWorker'</span><span class="token punctuation">;</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.StrictMode</span></span><span class="token punctuation">></span></span><span class="token plain-text">    // It is main point. Set Store available    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Provider</span></span> <span class="token attr-name">store</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>store<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Provider</span></span><span class="token punctuation">></span></span><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.StrictMode</span></span><span class="token punctuation">></span></span><span class="token punctuation">,</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>If you’re interested, you can implement the demo yourself later, it’s a good way to quickly understand how redux works.</p><p>Clone the <a href="https://github.com/dragonwang-hub/react-redux-counter-demo">Counter Demo Example</a> to start to code the first react-redux project belongs to you now.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">UI/Container Components</a></li><li><a href="https://redux.js.org/tutorials/essentials/part-1-overview-concepts">Basic Concepts</a></li><li><a href="https://react-redux.js.org/using-react-redux/connect-mapstate">Connect Function</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
            <tag> store </tag>
            
            <tag> reducers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code之函数</title>
      <link href="2021/05/16/clean-code-zhi-han-shu/"/>
      <url>2021/05/16/clean-code-zhi-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Clean-Code-之函数"><a href="#Clean-Code-之函数" class="headerlink" title="Clean Code 之函数"></a>Clean Code 之函数</h1><p>在软件开发过程（Where）中，程序员（Who）随时随地都有需要编写函数（方法）大多数语言编写的系统都是以主函数main作为系统启动入口，这也从侧面表现出函数在软件系统中的重要性。在日常编程（When）中，函数也无处不在，如何编写一个好的函数就成为一个很重要的话题。</p><p>当然，部分读者会秉着”够用就好“的思想认为一个函数，由输入至输出可以实现基本功能就足以。但是作者认为，函数作为系统中无处不在的模块，应当具备规则去保证软件系统的<strong>高可重用性、高可扩展性、高可靠性</strong>。</p><p>本文结合《Clean Code》函数章节和《Alibaba Java 开发手册》部分内容。从以下几个方面分析如何编写一个好的函数：</p><h2 id="什么是好的函数"><a href="#什么是好的函数" class="headerlink" title="什么是好的函数"></a>什么是好的函数</h2><p>从结果而言，好的函数首要保证的是可执行并能完成基本功能。一个函数若不能执行，便沦为空谈，毫无意义，函数不能执行的原因可能与函数内部逻辑或执行环境有关。<br>但若是编写的函数没有实现预期的功能，那么该函数的意义也无从体现，其更多可能就是逻辑有误。并且若是函数正确执行但却做了意外之事，就会变得更令人迷惑。</p><p>从协作开发而言，好的函数需要具备可读性、可重用性、可靠性。提高函数的可读性，可以方便自己或他人理解并进行维护和修改。可重用性指函数的复用性，可多次调用，其没有过多的重复性代码，保证代码的整洁度。也从侧面体现了好的函数的优点。</p><p>绝大部分情况下，一个具有基本素质的工程师都会保证函数从结果上看都是完全合格的，即保证了可执行并正确实现功能。因此，从协作开发角度，如何实现函数的高可读性、高可重用性就尤为重要。</p><h2 id="编写优雅的函数"><a href="#编写优雅的函数" class="headerlink" title="编写优雅的函数"></a>编写优雅的函数</h2><p>《Clean Code》中对如何编写优雅的函数做出了几点建议。以下将进行简单总结：</p><h3 id="函数体的表现形式"><a href="#函数体的表现形式" class="headerlink" title="函数体的表现形式"></a>函数体的表现形式</h3><ul><li><p><strong>短小的函数可读性更佳</strong>。在几十年前，因为硬件限制，建议函数长度不长于一屏（不利于整体阅读）。建议一个函数<strong>最长不过20行</strong>，若需要描述逻辑过多，可以对函数内逻辑进行提炼，保证一个函数实现一个目的。</p></li><li><p>在初学编程之际，我们通常会在main函数内写入所有逻辑，不懂分层提炼等等。但在实际系统开发中，<strong>一个函数只做一件事</strong>就尤为重要，更利于代码的编写与维护。<strong>判断函数是否只做了一件事可以看此函数内部是否可以再提炼出有意义的更短小的函数。</strong>请记住，只做一件事的函数式无法被合理切分为多个区段的。</p></li><li><p>在函数只做一件事的同时，同样可以注意提炼相同逻辑代码来避免重复性，以提高函数的可重用性。当然，若函数的职责始终单一，重复的可能性便十分之小。</p></li><li><p>当然，在进行函数提炼时，需要注意函数的抽象层次结构。<strong>函数中的语句都要在同一个抽象层级最佳</strong>，不同的抽象层级不要放在一起。以一个经典案例表明，如何把大象放进冰箱：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushElephantIntoRefrige</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">openRefrige</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">pushElephant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">closeRefrige</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样保证内部函数在同一层次更利于代码自上而下的阅读规则。让每个函数后面跟着位于下一抽    象层级的函数，如此便可在查看函数列表时就能循着抽象层级向下阅读了。</p></li><li><p>在<strong>条件选择语句或循环语句中，若能实现其内代码块只占一行</strong>，即将其内部代码逻辑提炼为一个私有函数，也可以保证更好的可读性。当然这也就会保证函数内的嵌套层级不会太多。</p></li><li><p>若函数内有多种异常情况需要处理，应当<strong>将错误处理代码和主路径代码进行分离</strong>，以保障主干代码的整洁程度。若使用了try/catch代码块，可以将其内部代码块进行提炼。</p></li></ul><h3 id="函数的名与参"><a href="#函数的名与参" class="headerlink" title="函数的名与参"></a>函数的名与参</h3><ul><li><p>当函数极为短小且精悍时，函数只做一件事，再用一个优雅的命名描述这一件事便可造就一个优雅的函数。在对提炼函数命名时，要考虑的便是如何<strong>保证一系列函数的命名一致性</strong>。使用前后一致的模块名为相关联的函数进行命名。保证函数名清晰有效的描述清楚其功能即可，不必拘束于函数名称长短，<strong>函数名与功能统一且单一</strong>即可。</p></li><li><p>对于函数的参数，理想的参数数量是零个，建议<strong>不要使用三个及以上的参数数量</strong>。参数数量过多，会对测试覆盖和代码阅读提高难度。对于函数的参数，可以遵循以下几点建议：</p><ol><li>不要使用参数作为输出。无论是使用指针还是引用，将函数的入参作为函数结果的输出是十分不利于函数的阅读的。因此，若要对函数输入参数进行转换操作，建议转换结果作为函数返回值返回。</li><li>函数中不要使用标识参数（比如Boolean 类型参数）。若使用标识参数，则此函数必然做了不止一件事，其次，会增加阅读难度。因此，在这类情况中，可以将函数划分提炼为两个下一抽象层级的函数。</li><li>若有多参数的需求，可以考虑重构函数以减少入参个数。或将多个参数抽象封装为一个对象，以减少参数数量。</li><li>若函数有参数，可将函数与参数命名结合形成良好的动词与名称对的形式。</li></ol></li></ul><h3 id="实践是检验真理的唯一途径"><a href="#实践是检验真理的唯一途径" class="headerlink" title="实践是检验真理的唯一途径"></a>实践是检验真理的唯一途径</h3><p>书中曾言：</p><blockquote><p>写代码与写文章很像，先有初稿，再不断打磨，直至达到心目中的样子。</p><p>函数是语言的动词，类是名称。</p><p>对于函数而言，一开始只实现功能，<strong>冗长且复杂，缩进与嵌套比比皆是，还有过长的参数列表，随意的名称，重复的代码等等。</strong></p><p>然后经过打磨，<strong>分解函数、赋予有意义的名称、提炼函数、消除重复代码等等</strong>，经过重重升级，获得最终版优雅的函数。</p></blockquote><p>实践是检验真理的唯一途径。本文结合作者粗略的见解进行了总结与分析。<br>但“如何写好函数”本就是一个偏主观的话题，在编程实践中人人都会积累了大量客观的评价指标，其中有些指标可能是相互制约的，例如复用性、可扩展性、可读性，三者就不容易共同提高。写好函数的重要性是不言而喻的。“编程一时爽，重构火葬场”的俚语人人时常耳闻。因此，我们可以在实践中不断改进提升我们的代码，从函数到系统架构，以小积大，构建优雅的系统故事。</p><p>从今天开始，从此刻开始，拿出之前的书写的函数代码，操作起来。Do IT.</p><p><strong>Reference</strong></p><ol><li><p>《Clean Code》</p></li><li><p>《Java 开发手册》：<a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf">https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Java </tag>
            
            <tag> 代码整洁/规范 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three Factory Pattern</title>
      <link href="2021/04/20/three-factory-pattern/"/>
      <url>2021/04/20/three-factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="浅入浅出三种工厂模式"><a href="#浅入浅出三种工厂模式" class="headerlink" title="浅入浅出三种工厂模式"></a>浅入浅出三种工厂模式</h1><h2 id="引言（设计模式的目的）"><a href="#引言（设计模式的目的）" class="headerlink" title="引言（设计模式的目的）"></a>引言（设计模式的目的）</h2><p>我们常说设计原则，设计模式。到底设计模式是如何出现的？设计模式的目的是什么呢 ？<br>相信各位读者或多或少都听过，SOLID设计原则，20+中设计模式中的一些术语。</p><p>设计模式首次被提出是出现在GoF的《Design Patterns - Elements of Reusable Object-Oriented Software》一书。自此之后GoF 23种设计模式常常出现在各个论坛。<br>GoF其实也是Gang of Four的简称。</p><p>那么归根结底，其目的是什么？<br>设计原则是几种理念的总结，其主要代表的是实现系统的<strong>高内聚、低耦合</strong>，并且同时找到系统的变化点，使用一些技术手段实现<strong>分离变化与稳定</strong>。进而保证软件系统的<strong>高可重用性、高可扩展性、高可靠性</strong>。</p><p>设计模式是基于设计原则的一些实践方法模式，其未必能满足所有的原则，但会有其专有的一些特点，以适用不同的系统场景。<br>曾有老师将学习设计模式的程度分为四境界，此处做一引用</p><blockquote><p>第一阶段：手中无剑，心中无剑<br>第二阶段：手中有剑，心中无剑<br>第三阶段：手中有剑，心中有剑<br>第四阶段：手中无剑，心中有剑</p></blockquote><p>本文主要针对<strong>三种工厂模式（简单工厂、工厂方法、抽象工厂）</strong>进行简单的介绍和场景分析。</p><p><strong>注：</strong></p><p><em>若读者已达到第三阶段，可以直接command+q 或 alt+F4 退出，以免浪费时间。</em></p><p><em>本文示例代码有所精简，具体代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></em></p><h2 id="需求及基础实现（加减乘除）"><a href="#需求及基础实现（加减乘除）" class="headerlink" title="需求及基础实现（加减乘除）"></a>需求及基础实现（加减乘除）</h2><p>首先，从一个Demo讲起，现在有一个简单的功能开发，需求如下：</p><p>使用任一面向对象语言实现一个计算器控制台程序</p><ol><li>实现基本四则运算（+ - * /）</li><li>只需要两个数字输入</li><li>需要保证程序的可复用性</li></ol><p>相信，任何一个对面向对象三特性有些了解的读者都会写出如下程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> numberA<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> numberB<span class="token punctuation">;</span><span class="token comment">// setter and getter</span>    <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">String</span> operate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token number">0d</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>operate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span>                result <span class="token operator">=</span> numberA <span class="token operator">+</span> numberB<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span>                result <span class="token operator">=</span> numberA <span class="token operator">-</span> numberB<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span>                result <span class="token operator">=</span> numberA <span class="token operator">*</span> numberB<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span>                result <span class="token operator">=</span> numberA <span class="token operator">/</span> numberB<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Input operate is incorrect!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个封装的Operation类，其内使用switch分支判断选择运算的算法。调用方只需要传入数字和运算符即可获得结果。</p><p>针对需求，这段代码已经实现的比较不错了，使用封装特性将业务逻辑进行封装，降低了调用方与业务方的耦合。<br>但如果现在要添加一个幂运算，程序<strong>只能在switch中增加新分支</strong>。其次，此处运算算法（分支内内容）相当简单，若在复杂系统中，算法极其复杂，将会造成其switch分支包含过多职责的情况，而且，若是某分支的算法需要进行更改，则需要修改Operation类的内容。</p><p>仔细分析需求，观察此段代码，运算数字只有两个，分支中唯一的区别在于运算符。<br>若能<strong>将具体的运算算法和数字初始化进行分离解耦</strong>，则便可以降低Operation的职责，再次进行解耦。因此可以构造父子类，赋予不同子类处理不同的运算算法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> numberA <span class="token operator">=</span> <span class="token number">0d</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> numberB <span class="token operator">=</span> <span class="token number">0d</span><span class="token punctuation">;</span><span class="token comment">// setter and getter</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OperationAdd</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OperationDiv</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OperationMul</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OperationSub</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// ...</span>        <span class="token class-name">Operation</span> operation <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>operate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span>                operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span>                operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span>                operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationMul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span>                operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationDiv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Input operate is incorrect!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        operation<span class="token punctuation">.</span><span class="token function">setNumberA</span><span class="token punctuation">(</span>numberA<span class="token punctuation">)</span><span class="token punctuation">;</span>        operation<span class="token punctuation">.</span><span class="token function">setNumberB</span><span class="token punctuation">(</span>numberB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> result <span class="token operator">=</span> operation<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The result is :"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这种系统结构，保证内部封装，和职责分离。但调用方依然在运算前需要进行分支选择实例化不同的对象。</p><p>对于调用者而言，其本不需要也不希望进行处理创建对象逻辑，其只需要传入参数调用方法计算结果即可。</p><p>因此，可以将<strong>分支选择实例化对象部分</strong>从此类进行剥离，构建工厂类。实现<strong>对象创建和对象使用的分离解耦</strong>。这就构成了一种简单的设计模式——简单工厂模式。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂包含三个角色：</p><ul><li>Factory：负责创建所有产品示例的内部逻辑</li><li>Abstract Product：所有产品对象抽象的父类，负责描述所有产品共有的公有接口</li><li>Concrete Product：负责创建具体产品实例</li></ul><img src="/2021/04/20/three-factory-pattern/image-20210419225812547.png" class="" alt="image-20210419225812547"><p>简单工厂的实现目的：</p><ol><li>对象创建和对象使用进行分离，解耦。</li><li>创建由工厂执行。Client只需要关注如何使用，甚至无需知道具体产品的类名</li></ol><p>因此，对于上述的四则运算示例，使用简单工厂模式实现，如下所示：</p><img src="/2021/04/20/three-factory-pattern/image-20210419230327451.png" class="" alt="image-20210419230327451"><p><strong>注： 代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p><p>使用一个工厂根据分支创建不同运算实例，进而通过调用方使用实例求解出具体结果。<br>实现了对象创建和使用的解耦，保证了运算算法的职责单一，只需要调用方传入参数，即可获取相应对象实例，并进行使用。</p><p>即使此时需要新增一两个运算法则，也只需要小改Operation类，增加新的具体产品类即可，但依然需要更改原有类结构。</p><p>若要增加一些运算法则，简单工厂模式又会显得力不能及。因为一旦将所有产品创建都放在一个工厂类，会使得该工厂类的职责过于庞大，进而引入一些新问题，这就是简单工厂模式的缺点。</p><ol><li><strong>工厂类不够灵活</strong>，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>依然<strong>没有完全符合开闭原则</strong>，增加新功能，依然需要修改工厂类。</li></ol><p>如果对工厂类灵活性有一定要求，并要保证完全符合开闭原则，可以选择使用工厂模式。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式包含四个角色：</p><ul><li>Abstract Factory：作为工厂方法模式的核心类，声明工厂方法，用于返回一个产品</li><li>Concrete Factory：抽象工厂类的子类，实现工厂方法，以供调用方调用，负责创建对应产品</li><li>Abstract Product：所有产品对象抽象的父类，负责描述所有产品共有的公有接口</li><li>Concrete Product：负责实现抽象产品接口，由专门的具体工厂创建，一一对应</li></ul><img src="/2021/04/20/three-factory-pattern/image-20210420200941754.png" class="" alt="image-20210420200941754"><p>工厂模式在简单工厂模式基础进行改造，声明核心工厂类和对应每个产品的具体工厂类，用于实现动态创建每一个产品。在工厂模式中：</p><ol><li>核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去实现。</li><li>实现了系统在不修改工厂角色的情况下增加新产品，保证了<strong>只扩展，不改变</strong>（开闭原则）。</li></ol><p>对于四则运算示例，其使用工厂模式实现，如下所示：</p><img src="/2021/04/20/three-factory-pattern/image-20210420201541535.png" class="" alt="image-20210420201541535"><p><strong>注： 代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p><p>使用核心工厂接口声明创建运算产品的工厂方法，再针对每个具体运算产品的创建去实现核心工厂类。因此，对于每种产品就有了其一一对应的具体工厂类。<br>当需要在系统中创建任何新的运算算法，都只需要编写相应的运算产品类和对应的工厂类。调用方在使用时直接实例化工厂实例，进而使用工厂对象生产产品实例再使用即可。</p><p><strong>既实现了对象创建和对象使用的分离解耦，又保证了系统的高灵活性、高扩展性。</strong></p><p>当然相对应简单工厂模式，虽然工厂模式<strong>提高了系统的灵活扩展性</strong>，但相应的也增加了系统的代码复杂度。每需增加新产品时，则需要编写新的产品类和对于工厂类。</p><p>工厂方法中，具体工厂和具体产品是一一对应。<strong>每个工厂只会生产对应的一种产品</strong>。但是有时候需要一个工厂提供多个产品对象，工厂模式就出现局限性。<br>比如针对上例，上例预算中所有的运算方法都没有对结果进行处理。现在需要针对四则运算的结果进行严格保留两位小数，并保证原有功能不变，可随意切换严格运算模式和普通运算模式。</p><p><strong>需求变更：</strong></p><p>针对这个需求变化，若直接在工厂模式上进行扩展，则会产生八个具体工厂类和对应的八个产品类。那么如何简化代码结构呢？这就引入了我们的抽象工厂模式，采用一个工厂类生产多个处于同一等级结构的产品实例。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>若要了解抽象工厂模式，需要明确两个概念：</p><ul><li>产品等级结构：表示产品的继承结构，主要是有继承关系的一系列的类结构。</li><li>产品族：由一个工厂创建，包含处于不同产品等级结构的一组产品。产品族内产品也具有一定关系。</li></ul><p>如果你还有疑惑，请看下图示例：</p><p>所有不同颜色的矩形可以继承于矩形父类，其作为一个产品等级结构。<br>每个工厂类可以创建处于同一等级结构的一组产品，这组产品也就是产品族。</p><img src="/2021/04/20/three-factory-pattern/image-20210420210312352.png" class="" alt="image-20210420210312352"><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p><p>抽象工厂模式也包含四个角色：</p><ul><li>Abstract Factory：声明生成抽象产品的方法，存在多个，针对每个产品等级结构都有不同的抽象产品类</li><li>Concrete Factory：抽象工厂类的实现类，负责创建一个产品族。</li><li>Abstract Product：所有产品对象抽象的父类，负责描述所有产品共有的公有接口</li><li>Concrete Product：负责实现抽象产品接口中定义的业务方法</li></ul><img src="/2021/04/20/three-factory-pattern/image-20210420211856445.png" class="" alt="image-20210420211856445"><p><strong>抽象工厂与工厂模式最大区别</strong>在于：工厂模式只针对一个产品等级结构，抽象工厂模式却可以面向多个产品等级结构。<br>因此，抽象工厂是最具有一般性的一种形态。当系统需要工厂生产的产品不是一个对象，而是一组对象时，就需要使用抽象工厂模式。使用抽象工厂，可以实现：</p><ol><li>具体工厂都实现了抽象工厂中定义的那些公共接口, 实现高内聚低耦合的设计目的</li><li>可以面向多个产品等级结构进行系统设计，并且保证调用方始终只使用同一个产品族中的对象。</li></ol><p>需要明确的一点在于，使用抽象工厂模式时，调用方只会同时使用同一产品族的对象。</p><p>那么针对运算示例新增加的严格运算模式的需求，使用抽象工厂实现示例如下：</p><img src="/2021/04/20/three-factory-pattern/image-20210420212355896.png" class="" alt="image-20210420212355896"><p><strong>注： 代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p><p>此处，对工厂类进行综合修改，保证每个工厂类可以创建一个产品族。因此，针对每个运算操作都抽象出相应的抽象产品类，并分别进行实现，构造了四个产品等级结构。这样就可以保证调用方<strong>每次选择一个统一的产品族</strong>使用。</p><p>相对而言，其结构较为复杂，而且也存在一些缺点</p><ul><li>增加新产品族时，只需新增工厂类和对应不同等级结构的产品类。但需要增加文件过多，以至于太复杂。</li><li>增加新的等级结构时，会对原有的具体工厂类进行改变，在其类内增加新方法，在一定程度不符合开闭原则。增加新产品族时不存在此问题。（<strong>开闭原则倾斜性</strong>）</li></ul><p>因此，抽象工厂模式中，更适用于<strong>具有多个产品等级结构</strong>的场景。为了更好的说明抽象工厂模式的使用场景，我们将引入一个被玩烂的示例，DB Demo：</p><p>简单描述：调用方需要适应多种数据库进行增删改查，数据库类型可以自定义更换。现有数据库包括Sqlserver和Access，但之后可能会引入Mysql等其他数据库。</p><p>这就需要设计的系统结构必须支持多个产品族的创建。使用抽象工厂模式直接创建具体工厂类，每个工厂类负责创建当前需求所需要使用的一系列表（产品族）。</p><img src="/2021/04/20/three-factory-pattern/image-20210420213945317.png" class="" alt="image-20210420213945317"><p><strong>注： 代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p><p>从这个实例中很容易感受到抽象工厂的魅力，调用方在某一时段只会选择一种数据库使用。使用抽象工厂模式创建多个产品族，在使用时直接指定某一产品族即可。</p><p>假设，现在要求增加一个新表，并且新表也有增删改查一套功能。则需要增加对应的产品等级结构，并在每个具体工厂类中，增加创建新表对象的方法。若此时系统已兼容多个数据库，则这一点需求的增加，就会导致大量代码文件的修改。</p><p>基于这类情况，提出新的思路，将所有工厂类揉合成一个工厂类，将抽象工厂退化为简单工厂，保证在要求增加一个新表，只需要改动一个工厂类即可。这时候，可能有读者会有所思考，那么简单工厂类中那些无处安放的分支选择语句是否应该处理呢？如果有多个产品对象，其对应的分支选择也必然十分庞大。</p><p>既然提出了问题，自然是需要解决的。</p><h2 id="反射-简单工厂模式（DB-Demo）"><a href="#反射-简单工厂模式（DB-Demo）" class="headerlink" title="反射+简单工厂模式（DB Demo）"></a>反射+简单工厂模式（DB Demo）</h2><p>针对上述DB Demo的抽象工厂示例，在将其简化为简单工厂后，使用反射技术，通过<strong>配置文件配置相应使用的产品族</strong>，当更换产品族时，不需更改任何业务代码，只需要修改配置文件即可。用反射技术去除分支选择语句可以<strong>解除分支选择带来的耦合</strong>，进而提高可扩展性。</p><p>代码示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 简单工厂类，创建所有产品</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataAccess</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> DB <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IUser</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> classFullName <span class="token operator">=</span> <span class="token string">"AFdbdemo.reflectaddsimplefactory.product.user."</span> <span class="token operator">+</span> DB <span class="token operator">+</span> <span class="token string">"User"</span><span class="token punctuation">;</span>        <span class="token class-name">IUser</span> iUser <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            iUser <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IUser</span><span class="token punctuation">)</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classFullName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Failed to Create User Table, DB is"</span> <span class="token operator">+</span> DB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> iUser<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IDepartment</span> <span class="token function">createDepartment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> classFullName <span class="token operator">=</span> <span class="token string">"AFdbdemo.reflectaddsimplefactory.product.department."</span> <span class="token operator">+</span> DB <span class="token operator">+</span> <span class="token string">"Department"</span><span class="token punctuation">;</span>        <span class="token class-name">IDepartment</span> iDepartment <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            iDepartment <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IDepartment</span><span class="token punctuation">)</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classFullName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Failed to Create Department Table, DB is"</span> <span class="token operator">+</span> DB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> iDepartment<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 静态初始化块，初始化选择的数据库</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src/AFdbdemo/reflectaddsimplefactory/setting.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token class-name">DataAccess</span><span class="token punctuation">.</span>DB <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"DB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应系统结构与简单工厂一样。只是在工厂类中，不再使用分支选择去判断创建何种对象实例，使用反射技术直接实例化所需对象。</p><img src="/2021/04/20/three-factory-pattern/image-20210420215935029.png" class="" alt="image-20210420215935029"><p><strong>注： 代码可查看<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p><p>反射技术相对于简单工厂，其代码更复杂，同时也增加了些许资源消耗，比较适合对灵活性和扩展性要求高的场景。</p><p><em><strong>因作者当前水平有限，针对此节，若有错误，请多包含。若对反射技术有更深了解需求，请持续关注或转战他场。</strong></em></p><h2 id="总结（适用场景）"><a href="#总结（适用场景）" class="headerlink" title="总结（适用场景）"></a>总结（适用场景）</h2><p>针对三种工厂模式，优缺点及适用场景如下表：</p><table><thead><tr><th></th><th><strong>简单工厂模式</strong></th><th><strong>工厂模式</strong></th><th><strong>抽象工厂模式</strong></th><th><strong>反射+简单工厂</strong></th></tr></thead><tbody><tr><td>优点</td><td>1.对象创建和对象使用进行分离，解耦。  2.创建由工厂执行。Client只需要关注如何使用，甚至无需知道具体产品的类名</td><td>1.保持了简单工厂模式的优点  2.增加新的产品类时无须修改现有系统，只需扩展，无需改变。  3.系统具有良好的灵活性和可扩展性</td><td>1.隔离了具体类的生成，实现高内聚低耦合  2.保证客户端始终只使用同一个产品族中的对象  3.符合“开闭原则”（但具有倾斜性）  4.最为抽象和最具一般性的一种形态。</td><td>1. 引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</td></tr><tr><td>缺点</td><td>1.工厂类职责过大  2.系统扩展困难（不完全满足开闭原则）  3.增加了类的个数</td><td>1.增加新产品需要同时增加新工厂类，增加了复杂性</td><td>1.增加新的产品等级结构麻烦</td><td>1.增加了资源消耗  2.代码相对复杂（相对简单工厂）</td></tr><tr><td>适用场景</td><td>1.工厂类所需负责的对象较少。  2.客户端无需关注创建对象细节</td><td>1.工厂类负责创建对象较多，且需要高扩展性  2.客户端无需关注创建对象细节  3.面对一个产品等级结构</td><td>1.面对多个产品等级结构，多个产品族。但每次只使用其中某一产品族。  2.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</td><td>灵活性和扩展性要求高的场景</td></tr></tbody></table><blockquote><p>书中曾言：</p><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</p><p>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式</p></blockquote><p>作者认为：不管黑猫白猫，能抓住老鼠，必然是好猫。所以众工厂模式中，没有优劣，只有合适与否。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>本文部分图片和文字来源于各大博主。</p><ol><li><a href="https://blog.csdn.net/jerry11112/article/details/80618420?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&dist_request_id=1330144.24999.16181468673066339&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">【设计模式】简单工厂、工厂方法与抽象工厂的区别</a></li><li><a href="https://developer.aliyun.com/article/24335">使用反射增强简单工厂设计模式</a></li><li>《大话设计模式》</li></ol><p><strong>本文所有Demo代码见<a href="https://github.com/dragonwang-hub/three_factory_design_patterns">Github Repo</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern/设计模式 </tag>
            
            <tag> Factory Pattern/工厂模式 </tag>
            
            <tag> reflection/反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile 及 Docker-compose使用详解</title>
      <link href="2021/04/20/dockerfileanddocker-compose/"/>
      <url>2021/04/20/dockerfileanddocker-compose/</url>
      
        <content type="html"><![CDATA[<h1 id="Dockerfile-及-Docker-compose使用详解"><a href="#Dockerfile-及-Docker-compose使用详解" class="headerlink" title="Dockerfile 及 Docker-compose使用详解"></a>Dockerfile 及 Docker-compose使用详解</h1><p>前言：</p><p>本文将从如何定制Docker 镜像开始，主要分为两部分：Dockerfile和Docker-compose。</p><p>若读者从未使用过Docker，建议先了解Docker基本概念及相关指令再来阅读此文。</p><h2 id="Dockerfile-基础"><a href="#Dockerfile-基础" class="headerlink" title="Dockerfile 基础"></a>Dockerfile 基础</h2><p>众所周知，docker镜像是由多层文件系统联合组成，镜像构建时，是分层存储的前一层是后一层的基础，每一层构建完后不再改变，后一层的任何改变只发现在自己这层。</p><p>在docker中，运行一个容器的时候，将做的任何文件修改记录于容器存储层中。使用docker commit命令可以实现将容器的存储层保存为镜像。即，在原有镜像的基础上，叠加一层容器的存储层，以构成新的镜像。</p><h3 id="Dockerfile概念"><a href="#Dockerfile概念" class="headerlink" title="Dockerfile概念"></a>Dockerfile概念</h3><p>镜像定制的本质是定制每一层添加的配置和文件。因此，可以使用脚本来构建、定制镜像，把每一层的修改、安装、构建、操作的命令写入脚本即可。这个脚本定义为Dockerfile。</p><p>Dockerfile 是一个用来构建镜像的文本文件，文本包含一条条构建镜像所需的指令和说明。每条指令构建一层，因此每条指令的内容，就描述该层如何构建。</p><p>使用<code>docker build</code> 可以从Dockerfile文件中构建镜像，并且可以使用<code>-f</code>标志指向任何位置的Dockerfile类型文件。</p><p>注：<code>docker build</code> 默认会选择当前文件夹下命名为Dockerfile的文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t name:version <span class="token builtin class-name">.</span> docker build -f /path/to/dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tips：</p><p>docker build还可以通过git repo、指定tar压缩包、标准输入读取dockerfile内容方式构建镜像。</p><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p>对于Dockerfile文件，一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。’#‘ 为Dockerfile中的注释。</p><p>所谓定制镜像，就是以一个镜像为基础，在其上进行定制。</p><p>Docker从上到下顺序运行Dockerfile的指令。为了指定基本镜像，第一条指令必须是FROM。</p><p>本节将针对Dockerfile中的一些常用指令 <code>FROM、MAINTAINER、RUN、COPY、CMD、ENTRYPOINT、EXPOSE、VOLUME、ENV</code> 等进行详细讲解。</p><h4 id="FROM-指定基础镜像，必须为第一个指令"><a href="#FROM-指定基础镜像，必须为第一个指令" class="headerlink" title="FROM: 指定基础镜像，必须为第一个指令"></a>FROM: 指定基础镜像，必须为第一个指令</h4><p>基础镜像可在Docker hub查找。</p><p>若不想以任何镜像为基础，则可以使用Docker的特殊镜像scratch。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt;@&lt;digest&gt;# 示例FROM ubuntu:20.04FROM scratch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>tag和digest是可选的，若不声明，会使用latest版本的基础镜像</li></ul><h4 id="RUN-执行命名行命令"><a href="#RUN-执行命名行命令" class="headerlink" title="RUN: 执行命名行命令"></a>RUN: 执行命名行命令</h4><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式RUN &lt;command&gt;#shell执行RUN [&quot;&lt;excutable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]#exec执行# 示例RUN apt-get updateRUN [&quot;.&#x2F;build.sh&quot;,&quot;dev&quot;,&quot;with_frontend&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><p>因为每条指令都会建立一层，所以构建时每层东西不会自动在下一层删除。所以过多无意义的层会使镜像膨胀过大。构建时可以在构建完成后清理不需要的文件及缓存。</p></li><li><p>RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定–no-cache参数，如：docker build –no-cache</p></li></ul><h4 id="COPY-复制指令"><a href="#COPY-复制指令" class="headerlink" title="COPY: 复制指令"></a>COPY: 复制指令</h4><p>将构建上下文目录中源路径的文件/目录复制到容器的指定路径中。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;source1&gt;...  &lt;destination&gt;COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;source1&gt;&quot;,...  &quot;&lt;destination&gt;&quot;]# 示例COPY hom* &#x2F;mydir&#x2F;          # 添加所有以&quot;hom&quot;开头的文件  COPY hom?.txt &#x2F;mydir&#x2F;      # ? 替代一个单字符,例如：&quot;home.txt&quot;  COPY test relativeDir&#x2F;     # 添加 &quot;test&quot; 到 &#96;WORKDIR&#96;&#x2F;relativeDir&#x2F;  COPY test &#x2F;absoluteDir&#x2F;    # 添加 &quot;test&quot; 到 &#x2F;absoluteDir&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><p><code> [--chown=&lt;user&gt;:&lt;group&gt;]</code> 是可选参数，表示改变复制到容器内文件的用户和用户组属性。</p></li><li><p>源文件或源目录，也可以使用通配符表达式 * 和 ？</p></li><li><p>目标路径不存在时会自行创建</p></li></ul><h4 id="ADD-高级版复制指令"><a href="#ADD-高级版复制指令" class="headerlink" title="ADD: 高级版复制指令"></a>ADD: 高级版复制指令</h4><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式ADD [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;source1&gt;...  &lt;destination&gt;ADD [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;source1&gt;&quot;,...  &quot;&lt;destination&gt;&quot;]ADD &lt;url&gt; &lt;destination&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但其相对COPY有一些区别。</p><ol><li>带有自动解压缩功能</li><li>源路径可以是一个URL，网络资源（功能不实用，不推荐）</li><li>会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</li></ol><p>仅需注意，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD: 容器启动命令"></a>CMD: 容器启动命令</h4><p>为启动的容器指定默认运行的程序，程序运行结束，容器则结束。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式CMD &lt;command&gt; # shell 格式CMD [&quot;&lt;excutable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;] # excu格式CMD [&quot;&lt;param1&gt;,&lt;param2&gt;,...&quot;]# 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数# 示例CMD echo &quot;hello,dockerfile&quot;CMD[&quot;&#x2F;usr&#x2F;bin&#x2F;wc&quot;,&quot;--help&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>CMD指令指定的程序可被docker run命令行参数中指定要运行的程序所覆盖。</li><li>若Dockerfile中存在多个CMD指令，仅最后一个生效。</li><li>类似于RUN，但CMD在docker run时运行，RUN在docker build时运行。</li></ul><h4 id="ENTRYPOINT-入口点，配置容器使其可执行化"><a href="#ENTRYPOINT-入口点，配置容器使其可执行化" class="headerlink" title="ENTRYPOINT: 入口点，配置容器使其可执行化"></a>ENTRYPOINT: 入口点，配置容器使其可执行化</h4><p>功能类似于CMD指令，但可以读取docker run 命令行参数传入其ENTRYPOINT指定程序。不会被docker run命令行参数覆盖。即执行docker run时可以指定ENTRYPOINT运行所需参数。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] #可执行文件, 优先  ENTRYPOINT command param1 param2#shell内部命令# 示例ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;myip.ipip.net&quot; ]ENTRYPOINT curl -s &lt;url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>若在docker run 使用了 –entrypoint， 则也会覆盖ENTRYPOINT程序</li><li>若Dockerfile中存在多个ENTRYPOINT指令，仅最后一个生效。</li><li>指定ENTRYPOINT后，CMD含义发生改变，CMD内容(一般为变参)可作为参数传给ENTRYPOINT。<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>,eg <code>ENTRYPOINT [&quot;top&quot;,&quot;-b&quot;] CMD [&quot;-c&quot;]</code>代表<code>top -b -c</code></li></ul><h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV: 设置环境变量"></a>ENV: 设置环境变量</h4><p>定义环境变量。可用于后续指令和运行时应用。</p><p>通过环境变量可以使一份Dockerfile制作更多镜像，只需使用不同环境即可。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式ENV &lt;key&gt; &lt;value&gt; # key之后所有内容都是value，此格式一次只能设置一个ENVENV &lt;key&gt;&#x3D;&lt;value&gt; #此格式一次可设多个变量。对于空格，可使用”“包裹或者\符号转译。# 示例ENV name John VecitoENV name&#x3D;&quot;VV KK&quot; sex&#x3D;male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注</p><ul><li>Dockerfile文件内引用ENV变量时，使用<code>$&#123;ENV_NAME&#125;</code>即可。</li></ul><h4 id="ARG-构建运行时参数"><a href="#ARG-构建运行时参数" class="headerlink" title="ARG: 构建运行时参数"></a>ARG: 构建运行时参数</h4><p>构建参数，类似于ENV，但作用域不同。ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。即docker build过程中有效，构建好的镜像不存在此类参数。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式ARG &lt;param_name&gt;&#x3D;&lt;value&gt;# 示例ARG NODE_VERSION&#x3D;7.10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</li><li>ARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于当前的 FROM 指令中。</li><li>若多阶段构建（以FROM分界），在各个阶段中使用的变量都必须在每个阶段分别指定。</li></ul><h4 id="VOLUME-定义匿名卷（持久化容器内目录）"><a href="#VOLUME-定义匿名卷（持久化容器内目录）" class="headerlink" title="VOLUME: 定义匿名卷（持久化容器内目录）"></a>VOLUME: 定义匿名卷（持久化容器内目录）</h4><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)。</p><p>Dockerfile中声明了匿名卷但是run的时候没有使用 -v绑定匿名卷的话那么docker就会在默认绑定容器匿名卷的目录下绑定匿名卷。</p><p>目的在于避免重要数据因重启而丢失，以及容器不断变大的问题。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式VOLUME [&quot;path1&quot;,&quot;path2&quot;,...]VOLUME &lt;path&gt;# 示例VOLUME &#x2F;dataVOLUME [&quot;&#x2F;dir&#x2F;data&quot;,&quot;&#x2F;etc&#x2F;data&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>启动容器docker run时，可以通过 -v 参数修改挂载点。</li><li>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统。</li><li>卷可以一直存在，并且可在容器内共享重用。</li><li>创建单独数据卷指令<code>docker volume create &lt;VOLUME_NAME&gt;</code>,挂载卷可使用<code>--mount</code></li></ul><h4 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE: 暴露端口"></a>EXPOSE: 暴露端口</h4><p>声明运行时容器提供服务端口。EXPOSE 仅仅是声明容器使用的端口而已，并不会自动在宿主进行端口映射。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式EXPOSE &lt;port1&gt; &lt;port2&gt; ...# 示例EXPOSE 3000EXPOSE 80 3000EXPOSE 6666&#x2F;tcp 5555&#x2F;udp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li><li><code>docker run -p</code>，是映射宿主端口和容器端口。将容器的对应端口服务公开给外界访问。而EXPOSE只是声明而已。</li></ul><h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR: 指定工作目录"></a>WORKDIR: 指定工作目录</h4><p>用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。</p><p>因为Dockerfile每条指令都是一层，所以用cd指令并不能保证每条指令都在一个路径，因此WORKDIR可以指定工作目录，实现每层目录一致。</p><p>如该目录不存在，WORKDIR会帮你建立目录。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式WORKDIR &lt;work_dir&gt;# 示例WORKDIR &#x2F;app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER: 指定当前用户"></a>USER: 指定当前用户</h4><p>与WORKDIR类似，都是改变环境状态并影响以后的层。</p><p>USER改变的是执行指令的用户身份和用户组</p><p>但切换的用户必须事先已创建。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式USER &lt;User_name&gt;# 示例RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ONBUILD-执行延迟构建命令"><a href="#ONBUILD-执行延迟构建命令" class="headerlink" title="ONBUILD: 执行延迟构建命令"></a>ONBUILD: 执行延迟构建命令</h4><p>ONBUILD指令后跟的其他指令。在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 格式ONBUILD [INSTRUCTION]# 示例ONBUILD ADD . &#x2F;app&#x2F;srcONBUILD RUN &#x2F;usr&#x2F;local&#x2F;build --dir &#x2F;app&#x2F;src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些其他指令，类似于HEALTHCHECK、LEBAL、SHELL等，此处不做讲解，有兴趣自行查看：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/%E3%80%82">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/。</a></p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># Demo: first nginx Dockerfile# 基础镜像 centos v8FROM centos:8# 维护者 has been deprecatedMAINTAINER dragon.wangENV PATH &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin:$PATH# download link:# nginx: http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html# epel: https:&#x2F;&#x2F;rpmfind.net&#x2F;linux&#x2F;rpm2html&#x2F;search.php?query&#x3D;epel-releaseADD nginx-1.18.0.tar.gz &#x2F;usr&#x2F;local&#x2F;ADD epel-release-7-13.noarch.rpm &#x2F;usr&#x2F;local&#x2F;RUN rpm -ivh &#x2F;usr&#x2F;local&#x2F;epel-release-7-13.noarch.rpmRUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean allRUN useradd -s &#x2F;sbin&#x2F;nologin -M newuserWORKDIR &#x2F;usr&#x2F;local&#x2F;nginx-1.18.0RUN .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --user&#x3D;newuser --group&#x3D;newuser --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make installRUN echo &quot;daemon off;&quot; &gt;&gt; &#x2F;etc&#x2F;nginx.configure# 声明端口EXPOSE 8888CMD [&quot;nginx&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker-compose基础"><a href="#Docker-compose基础" class="headerlink" title="Docker-compose基础"></a>Docker-compose基础</h2><p>Docker Compose 是 Docker 官方开源的编排项目，负责实现对Docker容器集群的快速编排以实现快速的部署分布式应用。</p><p>一个项目可以由多个服务(容器)关联而成，Compose面向项目进行管理。</p><p>服务(service)：一个应用容器，实际上可以运行多个相同镜像的实例。</p><p>项目(project)：由一组关联的应用容器组成的一个完整的业务单元。</p><p>Docker Compose使用三步骤：</p><ul><li>使用Dockerfile定义应用程序的环境</li><li>使用docker-compose.yml定义构成应用程序的服务，使各服务可以在隔离环境一起运行</li><li>执行docker-compose up命令来启动运行整个应用程序</li></ul><h3 id="YML配置指令参考"><a href="#YML配置指令参考" class="headerlink" title="YML配置指令参考"></a>YML配置指令参考</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>因此，YML配置十分重要。接下来将依次说明不同指令的含义：</p><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定当前yml文件将依从compose的版本。</p><p><code>version: &#39;2&#39;</code></p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定构建当前镜像上下文路径，</p><p><code>build: ./dir</code></p><p>或者作为具有上下文指定路径的对象 (配置可选的Dockerfile和args)。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span><span class="token key atrule">context</span><span class="token punctuation">:</span> ./dir <span class="token comment">#上下文路径</span><span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> dockerfile_dev <span class="token comment">#指定构建镜像的Dockerfile文件名</span><span class="token key atrule">args</span><span class="token punctuation">:</span><span class="token key atrule">env_var</span><span class="token punctuation">:</span> var_in_build <span class="token comment">#添加构建参数，只能在构建过程中访问的环境变量</span><span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> "com.example.label"=label <span class="token comment">#设置构建镜像的标签</span><span class="token key atrule">target</span><span class="token punctuation">:</span> dev <span class="token comment"># 多层构建时，指定构建的哪一层</span><span class="token key atrule">cache_from</span><span class="token punctuation">:</span> <span class="token comment"># 指定构建镜像的缓存</span><span class="token punctuation">-</span> <span class="token key atrule">alpine</span><span class="token punctuation">:</span> lastest<span class="token punctuation">-</span> <span class="token key atrule">corp/web_app</span><span class="token punctuation">:</span> <span class="token number">3.14</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add/cap_drop"></a>cap_add/cap_drop</h4><p>指定容器内核能力（capacity）的分配。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">cap_add</span><span class="token punctuation">:</span> <span class="token comment">#add 添加功能</span><span class="token punctuation">-</span> All<span class="token comment"># 让容器拥有所有能力</span><span class="token key atrule">cap_drop</span><span class="token punctuation">:</span> <span class="token comment">#drop 删除功能</span><span class="token punctuation">-</span> NET_ADMIN<span class="token comment"># 去掉NET_ADMIN能力</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动时默认命令。</p><p><code>command: echo &quot;hello, docker-compoe&#39;s command&quot;</code></p><h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>指定容器的父cgroup组，该容器可继承该组的资源限制。</p><p><code>cgroup_parent: group_name</code></p><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p><code>container_name: custom_name</code></p><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>设置容器之间的依赖关系，决定启动先后顺序。</p><p>当使用docker-compose up命令启动容器时，以依赖性顺序启动服务。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.7"</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token key atrule">web</span><span class="token punctuation">:</span> <span class="token key atrule">build</span><span class="token punctuation">:</span> .<span class="token key atrule">depends_on</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> db<span class="token punctuation">-</span> redis<span class="token key atrule">redis</span><span class="token punctuation">:</span><span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">db</span><span class="token punctuation">:</span><span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此示例存在依赖关系，会先启动db和redis，再启动web容器。但注意，web服务不会等redis、db完全启动后才启动。</p><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射列表。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">devices</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token string">"/dev/ttyUSB0:/dev/ttyUSB0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义DNS服务器，可以是一个值，也可以是一个列表的多个值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dns</span><span class="token punctuation">:</span> 8.8.8.8<span class="token key atrule">dns</span><span class="token punctuation">:</span><span class="token punctuation">-</span> 8.8.8.8<span class="token punctuation">-</span> 114.114.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>自定义配置DNS搜索域，可以是单个值或列表的多个值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dns_search</span><span class="token punctuation">:</span> example.com<span class="token key atrule">dns_search</span><span class="token punctuation">:</span><span class="token punctuation">-</span> dct1.example.com<span class="token punctuation">-</span> dct2.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>覆盖容器默认的entrypoint。</p><p><code>entrypoint: /code/entrypoint.sh</code></p><p>当然，也可以是命令行格式</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">entrypoint</span><span class="token punctuation">:</span><span class="token punctuation">-</span> php<span class="token punctuation">-</span> d<span class="token punctuation">-</span> zend_extension=/usr/local/lib/php/extensions/no<span class="token punctuation">-</span>debug<span class="token punctuation">-</span>nono<span class="token punctuation">-</span>zts<span class="token punctuation">-</span> d<span class="token punctuation">-</span> memory_limit=<span class="token punctuation">-</span><span class="token number">1</span><span class="token punctuation">-</span> vendor/bin/phpunit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从<strong>文件</strong>添加环境变量，可以是单个值或列表的多个值。</p><p><code>env_file: .env</code></p><p>列表格式：用于添加一组环境变量</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">env_file</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> ./common.env<span class="token punctuation">-</span> ./apps/web.env<span class="token punctuation">-</span> /opt/secrets.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量文件中的每一行必须符合格式。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">PROG_ENV=development<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>添加环境变量，可以使用数组或字典、任何布尔值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span><span class="token key atrule">RACK_ENV</span><span class="token punctuation">:</span> development<span class="token key atrule">SHOW</span><span class="token punctuation">:</span> <span class="token string">'true'</span><span class="token key atrule">SESSION_SECRET</span><span class="token punctuation">:</span> <span class="token key atrule">environment</span><span class="token punctuation">:</span><span class="token punctuation">-</span> RACK_ENV=development<span class="token punctuation">-</span> SESSION_SECRET<span class="token punctuation">-</span> SHOW='true'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>布尔值需要用引号引起来。</li><li>只给定名称的变量会自动获取运行compose主机上对应变量的值，可以用来防止泄露不必要的数据。</li></ul><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">expose</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token string">"3000"</span> <span class="token punctuation">-</span> <span class="token string">"8000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加主机名映射。类似docker client –add-host</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">extra_hosts</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token string">"firsthostname:10.46.23.60"</span><span class="token punctuation">-</span> <span class="token string">"secondhostname:50.31.20.229"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上会在此服务的内部容器中/etc/hosts创建一个具有ip地址和主机名的映射关系：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">10.46.23.60 firsthostname50.31.20.22 secondhostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令用于检查容器是否健康运行。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">healthcheck</span><span class="token punctuation">:</span> <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost"</span><span class="token punctuation">]</span> <span class="token comment"># 设置检测程序</span> <span class="token key atrule">interval</span><span class="token punctuation">:</span> 1m30s <span class="token comment"># 设置检测间隔</span> <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 10s <span class="token comment"># 设置检测超时时间</span> <span class="token key atrule">retries</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 设置重试次数</span> <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 40s <span class="token comment">#启动后，多少秒开始启动检测程序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像ID。如果镜像在本地不存子啊，compose将会尝试拉取这个镜像。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">image</span><span class="token punctuation">:</span> ubuntu<span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token number">8.1</span><span class="token key atrule">image</span><span class="token punctuation">:</span> orchardup/postgresql<span class="token key atrule">image</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>registry.com<span class="token punctuation">:</span>4000/mysql<span class="token key atrule">image</span><span class="token punctuation">:</span> a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="loggging"><a href="#loggging" class="headerlink" title="loggging"></a>loggging</h4><p>服务的日志记录配置。</p><p>driver: 指定服务容器的日志记录驱动程序，默认值为json-file。具有三个选项：<code>json-file、syslog、none</code></p><p>option 配置日志驱动的相关参数</p><ul><li><p>json-file示例（可以使用参数max-size、max-file限制日志的数据和大小）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span> <span class="token key atrule">driver</span><span class="token punctuation">:</span> json<span class="token punctuation">-</span>file <span class="token key atrule">options</span><span class="token punctuation">:</span>  <span class="token key atrule">max-size</span><span class="token punctuation">:</span> <span class="token string">"200k"</span> <span class="token comment"># 单个文件大小为200k</span> <span class="token key atrule">max-file</span><span class="token punctuation">:</span> <span class="token string">"10"</span> <span class="token comment"># 最多10个文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：当达到文件限制上限，会自动删除旧的文件。</p></li><li><p>syslog驱动程序下，可以使用<strong>syslog-address指定日志接收地址</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span><span class="token key atrule">driver</span><span class="token punctuation">:</span> syslog<span class="token key atrule">options</span><span class="token punctuation">:</span><span class="token key atrule">syslog-address</span><span class="token punctuation">:</span> <span class="token string">"tcp://192.168.0.42:9999"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。使用和docker run的 –network 参数一样的值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"bridge"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"host"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"none"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"service:[service name]"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"container:[container name/id]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络，引用顶级networks下的条目。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span><span class="token key atrule">custom-service</span><span class="token punctuation">:</span><span class="token key atrule">networks</span><span class="token punctuation">:</span><span class="token key atrule">first-network</span><span class="token punctuation">:</span><span class="token key atrule">aliases</span><span class="token punctuation">:</span><span class="token punctuation">-</span> alias1<span class="token key atrule">second-network</span><span class="token punctuation">:</span><span class="token key atrule">aliases</span><span class="token punctuation">:</span><span class="token punctuation">-</span> alias2<span class="token key atrule">networks</span><span class="token punctuation">:</span><span class="token key atrule">first-network</span><span class="token punctuation">:</span><span class="token key atrule">driver</span><span class="token punctuation">:</span> custom<span class="token punctuation">-</span>driver<span class="token punctuation">-</span><span class="token number">1</span><span class="token comment"># use a custom driver</span><span class="token key atrule">second-network</span><span class="token punctuation">:</span><span class="token key atrule">driver</span><span class="token punctuation">:</span> custom<span class="token punctuation">-</span>driver<span class="token punctuation">-</span><span class="token number">2</span> <span class="token comment"># use a custom driver which takes special options</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>aliases: 同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</li></ul><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>用于存储敏感收据。比如密码等</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.1"</span><span class="token key atrule">services</span><span class="token punctuation">:</span><span class="token comment"># ......</span><span class="token key atrule">mysql</span><span class="token punctuation">:</span><span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token key atrule">environment</span><span class="token punctuation">:</span><span class="token key atrule">MYSQL_ROO_PASSWORD_FILE</span><span class="token punctuation">:</span> /run/secrets/db_secret<span class="token key atrule">secrets</span><span class="token punctuation">:</span><span class="token punctuation">-</span> db_secret<span class="token punctuation">-</span> other_secret<span class="token key atrule">secrets</span><span class="token punctuation">:</span><span class="token key atrule">db_secret</span><span class="token punctuation">:</span><span class="token key atrule">file</span><span class="token punctuation">:</span> ./my_secret.txt<span class="token key atrule">other_secret</span><span class="token punctuation">:</span><span class="token key atrule">external</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>修改容器默认的schema标签。指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">security-opt</span><span class="token punctuation">:</span><span class="token punctuation">-</span> label<span class="token punctuation">:</span>user<span class="token punctuation">:</span>USER<span class="token comment"># 设置容器的用户标签</span><span class="token punctuation">-</span> label<span class="token punctuation">:</span>role<span class="token punctuation">:</span>ROLE<span class="token comment">#设置容器的角色标签</span><span class="token punctuation">-</span> label<span class="token punctuation">:</span>type<span class="token punctuation">:</span>TYPE<span class="token comment">#设置容器的安全策略标签</span><span class="token punctuation">-</span> label<span class="token punctuation">:</span>level<span class="token punctuation">:</span>LEVEL<span class="token comment">#设置容器的安全等级标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>设置容器中的内核参数，可以使用数组或字典格式。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 字典格式</span><span class="token key atrule">sysctls</span><span class="token punctuation">:</span><span class="token key atrule">net.core.somaxconn</span><span class="token punctuation">:</span> <span class="token number">1024</span><span class="token key atrule">net.ipv4.tcp_syncookies</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token comment"># 数组格式</span><span class="token key atrule">sysctls</span><span class="token punctuation">:</span><span class="token punctuation">-</span> net.core.somaxconn=1024<span class="token punctuation">-</span> net.ipv4.tcp_syncookies=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 单值形式</span><span class="token key atrule">tmpfs</span><span class="token punctuation">:</span> /run<span class="token comment"># 列表形式</span><span class="token key atrule">tmpfs</span><span class="token punctuation">:</span><span class="token punctuation">-</span> /run<span class="token punctuation">-</span> /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息以供外部服务调用。使用主机端口：容器端口格式(HOST:CONTAINER)。或者可以只指定容器的端口，主机端口将随机选择。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token string">"3000"</span><span class="token punctuation">-</span> <span class="token string">"8000:8000"</span><span class="token punctuation">-</span> <span class="token string">"41900:22"</span><span class="token punctuation">-</span> <span class="token string">"127.0.0.1:8001:8001"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>建议数字串都采用引号包括起来的字符串格式。</li></ul><h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的ulimits限制值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ulimits</span><span class="token punctuation">:</span><span class="token key atrule">nproc</span><span class="token punctuation">:</span> <span class="token number">65535</span><span class="token comment"># 指定最大进程数65535</span><span class="token key atrule">nofile</span><span class="token punctuation">:</span><span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">20000</span><span class="token comment"># 指定文件句柄数20000（软限制，应用随刻可以修改）</span><span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">40000</span> <span class="token comment"># 指定文件句柄数40000（硬限制，只能root用户提高）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。形式可以为：</p><p>宿主机路径：容器路径（HOST: CONTAINER）</p><p>数据卷名称：容器路径（VOLUME: CONTAINER）</p><p>同时，挂载的卷可以设置访问模式（eg. HOST: CONTAINER: ro）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.7"</span><span class="token key atrule">services</span><span class="token punctuation">:</span><span class="token key atrule">db</span><span class="token punctuation">:</span><span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">8.0</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span><span class="token punctuation">-</span> /data/postgres.sock<span class="token punctuation">:</span>/var/run/postgres/postgres.sock<span class="token punctuation">-</span> /tmp/data<span class="token punctuation">:</span>/var/lib/postgresql/data<span class="token punctuation">-</span> sql_data<span class="token punctuation">:</span>/var/lib/sql<span class="token key atrule">volumes</span><span class="token punctuation">:</span>sql_data<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然对于配置文件而言，还有很多指令<code>domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code>等，此处不再一一讲解。</p><p>具体查询可再看此link：<a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md">https://github.com/compose-spec/compose-spec/blob/master/spec.md</a></p><h3 id="docker-compose-常用命令"><a href="#docker-compose-常用命令" class="headerlink" title="docker-compose 常用命令"></a>docker-compose 常用命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -v/version <span class="token comment">#查看版本</span>docker-compose build <span class="token comment">#构建或重新构建服务</span>docker-compose <span class="token function">ps</span><span class="token comment">#列出本地运行的容器[-q 只列出id]</span>docker-compose images <span class="token comment"># 列出本地运行的镜像[-q 只列出id]</span>docker-compose logs -f --tail <span class="token number">200</span> <span class="token operator">&lt;</span>service_name<span class="token operator">></span> <span class="token comment">#跟踪打印service最后20行日志</span>docker-compose up <span class="token punctuation">[</span>option_param<span class="token punctuation">]</span> <span class="token comment">#默认为前台构建、启动容器[-d 后台构建、启动容器]</span>docker-compose start <span class="token operator">&lt;</span>service_name<span class="token operator">></span> <span class="token comment">#启动容器，但可能不是读取最新的yml配置</span>docker-compose stop/kill <span class="token operator">&lt;</span>service_name<span class="token operator">></span> <span class="token comment">#停止容器</span>docker-compose pull <span class="token comment"># 下载服务镜像</span>docker-compose run <span class="token operator">&lt;</span>service_name<span class="token operator">></span> <span class="token operator">&lt;</span>command<span class="token operator">></span> <span class="token comment"># 在服务上执行一个命令</span>docker-compose port <span class="token operator">&lt;</span>service_name<span class="token operator">></span> <span class="token operator">&lt;</span>ports<span class="token operator">></span> <span class="token comment">#打印服务上绑定的对外端口</span>docker-compose network <span class="token function">ls</span> <span class="token comment">#查看所有网络配置</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多指令查询可查看link：<a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><p>Github repo:(可联系博主申请权限)<br><a href="https://github.com/dragonwang-hub/docker-compose-front-back-sql">https://github.com/dragonwang-hub/docker-compose-front-back-sql</a><br><strong>前提：</strong></p><p>已存在可本地运行的前后端分离项目。</p><ul><li>Frontend: react+js+parcel</li><li>Backend:  springboot+java+gradle</li><li>SQL: mysql:8</li></ul><p><strong>需求：</strong></p><p>目前已有项目需要使用Dockerfile构建镜像，并使用Docker-compose进行编排容器管理启动。</p><ul><li>使用docker-compose up运行，即可在物理机运行项目。</li><li>SQL数据持久化, restart不影响数据。</li><li>分布在不同的networks。</li></ul><h3 id="Dockerfile构建镜像"><a href="#Dockerfile构建镜像" class="headerlink" title="Dockerfile构建镜像"></a>Dockerfile构建镜像</h3><p><strong>frontend</strong></p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># # Stage 1FROM node:14 as build-stepWORKDIR &#x2F;appCOPY . &#x2F;appRUN yarn installRUN yarn build# # Stage 2FROM nginx:1.19COPY .&#x2F;app&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html # 此处使用parcel打包工具，因此build后文件在dist目录下COPY .&#x2F;app&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.confEXPOSE 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><p>若本地已build过前端项目，已产生build后的文件，则直接进入stage2进行打包镜像，注释掉stage1代码即可。</p><p>（当然，目前只是build docker镜像，不曾考虑部署服务器。具体命令含义可参考本文基础部分）</p><p><strong>backend</strong></p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM openjdk:8COPY build&#x2F;libs&#x2F;*.jar &#x2F;app.jarENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar &#x2F;app.jar&quot;]EXPOSE 8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接将编译好的jar包存在镜像内，并使用java -jar命令运行即可。</p><h3 id="docker-compose-编排容器"><a href="#docker-compose-编排容器" class="headerlink" title="docker-compose 编排容器"></a>docker-compose 编排容器</h3><p><strong>架构图</strong></p><img src="/2021/04/20/dockerfileanddocker-compose/architeture.png" class="" alt="architeture.png"> <p><strong>代码</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> mysql<span class="token punctuation">-</span><span class="token number">8</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> library/mysql<span class="token punctuation">:</span>8.0.22    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> final_quiz      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> root      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> password      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> password    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>    <span class="token key atrule">expose</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token string">"3306"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token string">"db_sql:/var/lib/mysql"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> back<span class="token punctuation">-</span>network  <span class="token key atrule">backend</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> backend    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./B<span class="token punctuation">-</span>final<span class="token punctuation">-</span>quiz/ <span class="token comment"># dockerfile 路径</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">SPRING_DATASOURCE_URL</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//mysql<span class="token punctuation">:</span>3306/final_quiz      <span class="token key atrule">SPRING_DATASOURCE_USERNAME</span><span class="token punctuation">:</span> root      <span class="token key atrule">SPRING_DATASOURCE_PASSWORD</span><span class="token punctuation">:</span> password    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8080"</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> mysql    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> back<span class="token punctuation">-</span>network  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> frontend    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./F<span class="token punctuation">-</span>final<span class="token punctuation">-</span>quiz/ <span class="token comment"># dockerfile 路径</span>    <span class="token key atrule">expose</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token string">"80"</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token string">"9999:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> front<span class="token punctuation">-</span>network<span class="token comment"># 使用networks划分不同网络</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">back-network</span><span class="token punctuation">:</span>  <span class="token key atrule">front-network</span><span class="token punctuation">:</span><span class="token comment"># 创建volume卷挂载实现持久化</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">db_sql</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，一个简简单单的前端-后端-数据库的docker-compose编排示例就完结了。</p><p>希望这篇文章对您有所帮助，感谢阅读~<br><strong>Reference:</strong><br><a href="https://www.cnblogs.com/panwenbin-logs/p/8007348.html#autoid-1-0-0">https://www.cnblogs.com/panwenbin-logs/p/8007348.html#autoid-1-0-0</a><br><a href="https://yeasy.gitbook.io/docker_practice/compose/commands">https://yeasy.gitbook.io/docker_practice/compose/commands</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
            <tag> Docker-compose </tag>
            
            <tag> 容器编排 </tag>
            
            <tag> Ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code之命名</title>
      <link href="2021/04/09/clean-code-zhi-ming-ming/"/>
      <url>2021/04/09/clean-code-zhi-ming-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Clean-Code-之命名"><a href="#Clean-Code-之命名" class="headerlink" title="Clean Code  之命名"></a>Clean Code  之命名</h1><p>在软件开发过程（Where）中，程序员（Who）随时随地都有可能在命名，命名之事，无处不在。在编程（When）中，常见的命名范围：项目名、封包名、类名、方法名、变量名、参数名。</p><p>本文结合《Clean Code》有意义的命名章节和《Alibaba Java 开发手册》部分内容。从以下三个方面分析命名之道：</p><ol><li><strong>What：什么是好的命名</strong></li><li><strong>Why：为什么需要好的命名</strong></li><li><strong>How：如何实现优雅命名</strong></li></ol><h2 id="什么是好的命名"><a href="#什么是好的命名" class="headerlink" title="什么是好的命名"></a>什么是好的命名</h2><p>简单来说，好的命名就是，当别人看到你的代码时，可以清晰明确了解代码本身含义，不要额外付出去询问或查找每个命名的具体含义。</p><p>好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速理清程序的脉络。</p><p>无论是命名和注解，目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优雅的代码往往都见名知意。</p><p>《Clean Code》这本书明确指出：</p><blockquote><p><strong>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p><p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p></blockquote><p>优雅一词在代码领域流传甚久。</p><p>优雅的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！</p><blockquote><p>优雅一词，含义在于：外表或举止上令人愉悦的优美和雅观；令人愉悦的精致和简单。</p><p>其中，愉悦格外重要，显然优雅的代码也是令人阅读起来十分愉悦的。</p></blockquote><p>因此，好的命名必然是让每一位读者都赏心悦目，怀着愉悦心情阅读的。</p><h2 id="为什么需要好的命名"><a href="#为什么需要好的命名" class="headerlink" title="为什么需要好的命名"></a>为什么需要好的命名</h2><p>那么，为什么需要好的命名呢，难道只是为了让读者赏心悦目吗？</p><p>不仅仅如此。</p><p>借用《Java编程语言代码规范》一段开场白：</p><blockquote><p>一个软件需要花费80%的生命周期成本去维护。 　　<br>几乎没有任何软件的整个生命周期仅由其原作者来维护。 　　<br>编码规范改善软件的可读性,让工程师更快更彻底地理解新的代码。 　　<br>如果你将源代码转变为一个产品,那么您需要确保它和你创建的其它产品一样是干净且包装良好的。</p></blockquote><p>所以说，好的命名，其可读性，可维护性就很高。</p><p>接下来，引入以下几个示例了解为什么。</p><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">getThem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x <span class="token operator">:</span> theList<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span>      list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> list1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看完上例代码，是否有种看到初学编码时代的自己所写代码的感触。</p><p>根据这段代码，我们唯一能了解到的信息可能就是这是一段获取列表数据的代码。具体是什么，无法从代码明确。</p><p>如果需要明确此代码的具体含义，加上大量注释才可完成此目的。</p><p>那么，看完这段代码，你是否有很多问号？</p><ul><li>getThem到底获取了什么数据？</li><li>theList代表什么？</li><li>list1返回后用于做什么？</li><li>为什么theList元素等于4就被添加至list1？</li></ul><p>短短的几行代码便反应出这么些问题。</p><p>如果我们使用好的命名方式来修改代码，可以得到以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cell</span><span class="token punctuation">></span></span> <span class="token function">getFlaggedCells</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cell</span><span class="token punctuation">></span></span> flaggedCells <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Cell</span> cell<span class="token operator">:</span> gameBoard<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cell<span class="token punctuation">.</span><span class="token function">isFlagged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      flaggedCells<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> flaggedCells<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这部分代码，是否使你心情愉悦了呢？</p><p>简单的修改了命名，我们便能从代码理解其深层含义。回答上例几个问题：</p><ul><li>此方法获取了被标记的单元格列表数据。</li><li>之前的theList代表gameBoard，游戏地图的单元列表。</li><li>之前的list1存放的是被标记的单元格。</li><li>4则代表此单元格处于被标记状态。</li></ul><p>由此，我们便可知道，为什么。赋予好的命名可以提高代码可读性，便于理解交流。</p><p>好的命名可以使代码变得更加“优雅”。</p><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyChars</span><span class="token punctuation">(</span><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    a2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据这段代码，我们已经可以明确其目的在于复制字符数组。</p><p>但读者依然会有疑惑，对于a1、a2这类<strong>数字系列</strong>命名，其不显示具体含义，且外形极其相似。</p><p>如果不深入了解，未必明白a1、a2的编码者所传递的意图。</p><p>所以，我们可以修改参数名，以体现有意义的区分。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyChars</span><span class="token punctuation">(</span><span class="token keyword">char</span> source<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> destination<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    destination<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是修改了参数名，其就很好的区分了两参数区别，使阅读代码的人能迅速鉴别不同之处。</p><h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">34</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  sum <span class="token operator">+=</span> <span class="token punctuation">(</span>taskEstimate<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看到这段代码，可以明确其在遍历使用公式求和，但是如果并不明确其中具体算法，依然会处于懵逼树下懵逼果的状态。</p><p>并且，即使知道了数字常量所代表的含义，若要搜索其使用位置，也是十分困难的。</p><p>在《重构》中，将此方法中出现的常量数字称为Code Smell中的Magic Number，即魔法数字，代表无法理解其具体含义的数字。</p><p>因此，采用给常量赋予具体含义的命名可以解决此类问题。如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> realDaysPerIdealDay <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">int</span> WORK_DAYS_PER_WEEKS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER_OF_TASKS <span class="token operator">=</span> <span class="token number">34</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> NUMBER_OF_TASKS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> realTaskDays <span class="token operator">=</span> taskEstimate<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> realDaysPerIdealDay<span class="token punctuation">;</span>  <span class="token keyword">int</span> realTaskWeeks <span class="token operator">=</span> realTaskDays <span class="token operator">/</span> WORK_DAYS_PER_WEEKS<span class="token punctuation">;</span>  sum <span class="token operator">+=</span> realTaskWeeks<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对每个常量赋予真实意义的名字后，对于此代码理解更加容易。</p><p>测估完成所有任务的周数的算法。</p><p>既提高了代码可读性，又便于在任何位置搜索相关常量值。</p><h3 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbsClass</span> <span class="token punctuation">&#123;</span>  boolen condi<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">fu</span><span class="token punctuation">(</span><span class="token class-name">String</span> pa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>condi<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此代码中，随意使用简写，导致各命名含义模糊，无法理解。</p><p>即使使用简写模式，也应当使用大家有共识，都认可的方式才好。</p><p>如将简写命名改成全称，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClass</span> <span class="token punctuation">&#123;</span>  boolen condition<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token class-name">String</span> param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比即可发现，全称命名使代码意义直线上升，清晰明了。</p><p>好的命名不应当为了方便而随意使用简写。杜绝完全不规范的缩写，避免望文不知义。</p><h3 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> MAX_COUNT <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token class-name">EXPiRED_TIME</span> <span class="token operator">=</span> <span class="token number">1000l</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此例中常量命名全部大写，且long类型以l结尾。</p><p>但其中常量命名为了缩短名称长度。使得直知道是最大数量、过期时间，并不知其属于什么类型、领域。并且long类型以“l”结尾，“l”与1不易区分。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> MAX_STOCK_COUNT <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token class-name">CACHE_EXPiRED_TIME</span> <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改以后，代码更为清晰，确定了其中具体含义。因此好的命名要力求语义表达完整清楚，不要嫌名字长。</p><p>并且若不采用L结尾，很有可能误以为TIME值为10001。</p><p>…</p><p>根据以上介绍，相信每位读者心中都有一个答案，为什么要用好的命名。</p><p>不好的命名会增大代码理解难度，降低可读性，可维护性，从而导致开发人员费神费力，效率低下。</p><p>简单而言：好的命名可以让读者赏心悦目，怀着愉悦心情接受所有代码。优雅的命名可以提高代码可读性、区分性、可维护性等优点。</p><h2 id="如何实现优雅命名"><a href="#如何实现优雅命名" class="headerlink" title="如何实现优雅命名"></a>如何实现优雅命名</h2><p>很多人可能有了疑问，到底如何可以实现优雅命名呢？</p><p>本文将推荐以下几点：</p><ol><li><p>类名和对象名应当是名词或名词短语，避免动词或意义模糊的词语。</p></li><li><p>方法名应当是动词或动词短语。</p></li><li><p>类名使用UpperCamelCase风格。方法名、参数名、变量名统一使用lowerCamelCase风格。常量名全部大写，单词用下划线隔开。</p></li><li><p>包名统一小写，点分隔符之间有且只有一个自然语义单词。</p></li><li><p>抽象类命名使用Abstract或Base开头，异常类命名使用Exception结尾，测试类命名以Test结尾。枚举类名带上 Enum 后缀。</p></li><li><p>选择体现本意的命名以让人更容易理解和修改代码，命名简单直接，不要用俗语。避免中英混用，以及歧视性词语。</p></li><li><p>避免使用与本意相悖的词，避免留下掩藏代码本意的错误线索。在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。例如：使用list命名非List结构的数据。</p><pre class="line-numbers language-none"><code class="language-none">eg. Map&lt;int, User&gt; UserList;Map&lt;int, User&gt; UserMap;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>提防外形相似度较高的名称。eg. O和0，l和1</p></li><li><p>对命名做有意义的区分，以让读者准确鉴别不同之处。相同含义的名字不要重复出现，会导致混淆。</p></li><li><p>长名称优于短名称，搜得到的名称优于自造编码的名称。只要能描述清楚含义，尽量使用完整词组表达命名。单字母名称仅用于短方法的本地变量。名字长短应与其作用于带下相对应。</p></li><li><p>避免使用编码，已无需使用m_前缀来标明成员变量，已无意义。</p></li><li><p>避免出现同一个概念具有多个命名，应当统一为每个抽象概念选一个词，并一以贯之。</p></li><li><p>杜绝完全不规范的缩写，避免望文不知义。但可以使用领域专有术语。DO/VO/DTO/PO/POJO/UID等。如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。eg.工厂模式：public class OrderFactory;</p></li><li><p>单纯的命名无法解释含义，可引入语境前缀，多个字段具有相同语境前缀，可采用类封装，并给予合适命名。但不要在已具有语境的类中添加冗余的前缀。只要短名称即可描述清楚，则无需长名称描述。</p></li><li><p>分离解决方案领域和问题领域的概念，与问题领域更贴近代码应采用源自问题领域的名称。</p></li></ol><p><strong>Reference</strong></p><ol><li><p>《Clean Code》</p></li><li><p>《Java 开发手册》：<a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf">https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf</a></p></li><li><p>智能命名工具codeIf：<a href="https://unbug.github.io/codelf/">https://unbug.github.io/codelf/</a></p></li><li><p>DO、BO、DTO、VO、AO、PO、UID 名词意义：<a href="https://zhuanlan.zhihu.com/p/105390453">https://zhuanlan.zhihu.com/p/105390453</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech Improvement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Java </tag>
            
            <tag> 代码整洁/规范 </tag>
            
            <tag> 命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PlantUML 小白简易攻略</title>
      <link href="2021/02/20/plantuml-xiao-bai-jian-yi-gong-lue/"/>
      <url>2021/02/20/plantuml-xiao-bai-jian-yi-gong-lue/</url>
      
        <content type="html"><![CDATA[<h1 id="PlantUML-小白简易攻略"><a href="#PlantUML-小白简易攻略" class="headerlink" title="PlantUML 小白简易攻略"></a>PlantUML 小白简易攻略</h1><blockquote><p>因本文首次发布在牛客网，故而部分图片外链无法显示。可直接通过下方链接跳转牛客网查看。<br>Refer：<a href="https://blog.nowcoder.net/n/21fa67558e0141669ddc6970b336879c">https://blog.nowcoder.net/n/21fa67558e0141669ddc6970b336879c</a></p></blockquote><hr>  程序猿必备绘图工具PlantUML，不再像visio一样调整线条，边框，位置等等。只需要简单几行代码，export出最舒适的图。PlantUML 是一个开源项目，支持快速绘制时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。作为一款快速绘图工具，其更多的是让用户可以关注于业务逻辑，而不是绘图样式，排版等。其支持的文件后缀名是 *.wsd, *.pu, *.puml, *.plantuml, *.iuml<h2 id="1、PlantUML工具的三种姿势"><a href="#1、PlantUML工具的三种姿势" class="headerlink" title="1、PlantUML工具的三种姿势"></a>1、PlantUML工具的三种姿势</h2><h3 id="a、PlantUML-web-server"><a href="#a、PlantUML-web-server" class="headerlink" title="a、PlantUML web server"></a>a、PlantUML web server</h3><p>如果machine没有任何开发工具，那么也是可以使用浏览器绘制plantUML图的。<br>打开link： <a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a><br>即可开始绘制。<br>使用这种方式，不需要安装任何插件依赖，非常简单直接，但是不能实时预览图片，每次绘制完点击submit可以更新图片。</p><hr><p>当然，作为一名Dev，不会缺少必备开发工具。无论是Vs code 还是 IDEA, 或者其他，都可以安装PlantUML plugins。<br>注意如果你在本机使用需要以下依赖：</p><ul><li>Java : 是运行PlantUML的必需条件, 请在您的环境中安装Java</li><li>graphviz : 预览视图必须需要。[mac command :brew install graphviz]</li></ul><h3 id="b、Vs-code-安装PlantUML"><a href="#b、Vs-code-安装PlantUML" class="headerlink" title="b、Vs code 安装PlantUML"></a>b、Vs code 安装PlantUML</h3><p>按照以下步骤:</p><ol><li><p>打开vs code 插件管理栏，搜索palntUML，点击install安装<br>857 </p></li><li><p>常用的指令: alt/option + D 开启实时预览窗口<br>1015 </p></li><li><p>shift + command + p 调出命令行，输入plantUML,可以选择多种输出方式，包括export为图片，或者生成url。<br>1211 </p></li><li><p>在vs code中，可以在setting.json设置plantUML的自定属性。[一般不会使用]</p></li></ol><h3 id="c、IDEA-安装PlantUML"><a href="#c、IDEA-安装PlantUML" class="headerlink" title="c、IDEA 安装PlantUML"></a>c、IDEA 安装PlantUML</h3><ol><li>安装: 打开idea，快捷键command + ，打开设置，在左侧选择plugin点击，右侧搜索plantUML，安装<strong>PlantUML integration</strong><br>1498 </li><li>新建: 选择任意目录，新建文件，在弹出栏选择PlantUML，之后可以选择绘制的类型，Idea中会自动生成一个同类型的示例。<br>1687 </li><li>输出: 点击右侧预览图 save 按钮，即可输出至本地。（图片所示，为选择时序图后自动生成的样例）<br>1863 </li></ol><h2 id="2、PlantUML的多种使用姿势"><a href="#2、PlantUML的多种使用姿势" class="headerlink" title="2、PlantUML的多种使用姿势"></a>2、PlantUML的多种使用姿势</h2><p>当配置完成，就可以使用PlantUML绘制任意类型图，只有你想不到，没有它做不到。<br>首先，必须知道PlantUML采用DSL（领域特定语言）,语法简单易懂。<br><strong>每个file都以@startuml开头，以@enduml结尾</strong><br>但绘制不同类型图会采用不同的关键字。之后将讲解如何使用PlantUML绘制三种常用的图形。</p><h3 id="a、时序图"><a href="#a、时序图" class="headerlink" title="a、时序图"></a>a、时序图</h3><p>在时序图中，常用的关键字有：</p><ul><li>actor : 执行者，一般就是用户。</li><li>participant : 参与者，在时序图代表整个流程的关键角色</li><li>activate : 激活该角色生命周期，代表其起点</li><li>deactivate : 终止该角色生命周期，代表其终点, 若声明了activate, 而不声明deactivate, 则默认至结束</li><li>group : 用于分组某一部分时序为具体功能，以end为结束符</li><li>alt : 条件选择框，与else结合使用，代表两种不同的情况，以end为结束符</li><li>loop : 循环调用框，代表当前功能时序是一个循环过程，以end为结束符</li><li>return : 对应上一句的数据流向的反向（虚线）</li><li>note over: 显示一个标签框在当前位置，标记某些行为</li><li>autonumber : 用于自动生成数字标号<br>注：-&gt;为实线，–&gt;为虚线</li></ul><p><strong>时序图示例</strong></p><pre class="line-numbers language-none"><code class="language-none">@startumlautonumberactor User as userparticipant &quot;Browser UI&quot; as browserparticipant &quot;Reseller UI&quot; as reseller_uiactivate usergroup loginFunctionuser -&gt; browser : Visit the Reseller UI login pagebrowser -&gt; reseller_ui : Retrieve the Reseller UI login pageactivate reseller_uibrowser &lt;- reseller_ui : Return the login page with form field \nusername, password, and One Time Password(OTP)enduser &lt;- browser : Display the page, wait for user inputuser -&gt; user: Recall username and password \nfrom memoryuser -&gt; browser : Fill in the username and password fielduser -&gt; user: Open Google Authenticator, \nread the OTPuser -&gt; browser : Fill in the OTP, and hit the send buttonbrowser -&gt; reseller_ui : Send the username, password and OTPreseller_ui -&gt; reseller_ui : Verify the information is validalt Login valid    browser &lt;- reseller_ui : Return the logged in page    user &lt;- browser : Display the logged in pageelse Login invalid    browser &lt;- reseller_ui : Return login failure page    deactivate reseller_ui    user &lt;- browser : Display the login failure pageendloop at Loop_Examplenote over user : it_is_loop_exampleuser -&gt; browser : step 1 return nothinguser -&gt; reseller_ui : step 2return nothing againend@enduml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下为所根据代export的图片：<br>使用了group, alt, loop<br>4579 </p><h3 id="b、C4模型图"><a href="#b、C4模型图" class="headerlink" title="b、C4模型图"></a>b、C4模型图</h3><p>在描述软件架构方面，C4 model是非常不错的选择，其具有多个层次描述软件系统架构，非常清晰明了简单。并且此模型既可以在设计系统阶段使用，也可以在系统构建完成后使用。<br>使用PlantUML工具使得绘制C4model图变得异常简单。仅需要注意以下常用点即可：</p><ul><li>必须引入C4 container standard library (注意，使用此library，需要科学，负责无法打开此link): !include <a href="https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml">https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml</a></li><li>在C4 model中常用的Object类型有：<ol><li>Person/Person_Ext : 代表使用者，加上Ext(external）代表外部(灰色)<br>Person/Person_Ext(id, name, description)</li><li>System/System_Ext : 软件系统方框，Ext代表外部系统(灰色)<br>System/System_Ext(id, name, description)</li><li>Boundary/System_Boundary : 虚线边界框，可将多个模块放在同一Boundary内。<br>Boundary/System_Boundary(id, name)</li><li>Container : 可用于代表系统内部服务<br>Container(id, name, tech-stack, description)</li><li>Relationship : 各模块之间的关系<br>Rel(upstream, downstream, description, method)</li></ol></li></ul><p>C4 model 示例：（注，此示例仅为实现多个Object，未必是标准C4 model图）<br>在这示例代码中：</p><ul><li>LAYOUT_LEFT_RIGHT() : 保证图片排版从左至右，默认为上至下</li><li>HIDE_STEREOTYPE() : 隐藏方框类型标签<pre class="line-numbers language-none"><code class="language-none">@startuml System Context!include https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;plantuml-stdlib&#x2F;C4-PlantUML&#x2F;master&#x2F;C4_Container.pumlLAYOUT_LEFT_RIGHT()HIDE_STEREOTYPE()Person(user, &quot;User&quot;,&quot;description of user&quot;)System_Boundary(system_id, &quot;Web Application&quot;) &#123;    Container(ui, &quot;UI&quot;, &quot;React, TypeScript, Nginx&quot;, &quot;Frontend page.&quot;)    Container(api, &quot;API&quot;, &quot;Kotlin, Spring&quot;, &quot;Backend API&quot;)&#125;System_Ext(ext_system1, &quot;ext_system1&quot;,&quot; Code Hosting Platform for Version Control and Collaboration.&quot;)System_Ext(ext_system2, &quot;ext_system2&quot;, &quot;Website Performance and Availability Monitoring.&quot;)System_Ext(ext_system3, &quot;ext_system3&quot;,&quot;Open Source Analytics &amp; Monitoring for Multiple Data Sources.&quot;)Rel(user, ui, &quot;Uses&quot;, &quot;HTTPS&quot;)Rel(ui, api, &quot;Interact&quot;, &quot;HTTPS&quot;)Rel(api, ext_system1, &quot;Interact with&quot;, &quot;HTTPS&quot;)Rel(api, ext_system2, &quot;Gets ext data from&quot;, &quot;HTTPS&quot;)Rel(api, ext_system3, &quot;Gets ext data from&quot;, &quot;HTTPS&quot;)@enduml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>如下为所根据代export的图片：<br>使用了Person, System, Container, Rel<br>7301 </p><h3 id="c、流程图"><a href="#c、流程图" class="headerlink" title="c、流程图"></a>c、流程图</h3><p>任何时间、事件都有可能使用流程图。因此，我们最常用还是流程图，当然，PlantUML未失众望，其也是可以绘制流程图的。<br>基本流程图会涉及分支，循环，并行，终止等。使用此工具绘制流程图需要了解一下几点：</p><ul><li>start和end是流程图的开始和结束标志，其在图中显示为圆圈。</li><li>“: 文字” 表示流程图的工作环节，以方框显示</li><li>分支使用方法包括 <ol><li>if(condition?) then(yes/no) … else(no/yes) …</li><li>if(result?) is(what?) then … else …</li><li>if(counter?) equals(Number?) then … else …<br>注：分支中也有elseif 和 endif</li></ol></li><li>循环使用方法包括<ol><li>repeat[循环体首] … repeat while(condition?) is(yes/no)[循环体尾]<br>如需要在循环返回线中增加其他环节，则可以使用<strong>backward</strong>关键字<br>如需要在循环体中跳出，可以使用<strong>break</strong>关键字</li><li>while(conditon?) … endwhile</li><li>while(value?) is(exist?) … endwhile(not exist)</li></ol></li><li>若要终止某一分支，可以使用stop/kill/detach<br>注：每个工作环节都以;结尾<br>代码示例：<pre class="line-numbers language-none"><code class="language-none">@startumlstart:&quot;步骤1处理&quot;;:&quot;步骤2处理&quot;;if (&quot;条件1判断&quot;) then (true)    :条件1成立时执行的动作;    if (&quot;分支条件2判断&quot;) then (no)        :&quot;条件2不成立时执行的动作&quot;;    else        if (&quot;条件3判断&quot;) then (yes)            :&quot;条件3成立时的动作&quot;;        else (no)            :&quot;条件3不成立时的动作&quot;;        endif    endif    :&quot;顺序步骤3处理&quot;;endifif (&quot;条件4判断&quot;) then (yes):&quot;条件4成立的动作&quot;;else    if (&quot;条件5判断&quot;) then (yes)        :&quot;条件5成立时的动作&quot;;    else (no)        :&quot;条件5不成立时的动作&quot;;    endifendifrepeat    :循环体第一步;    :循环体第二步;    backward: 这是返回线的提示语;repeat while(&quot;条件判断&quot;) is (yes)while (&quot;while示例，检测文件流数据&quot; ?) is (&quot;存在未读取数据&quot;)    :读取文件;endwhile (文件读完):关闭文件;stop@enduml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>该流程export的图片如下：<br>使用了分支，及循环环节示例。<br>9574 </li></ul><p>至此，我们已经可以使用PlantUML绘制简单的模型图，本文所有示例只为展示各模块关键字，与具体业务无关。</p><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><p>如需要更多示例，可查看：<a href="https://real-world-plantuml.com/?type=usecase">https://real-world-plantuml.com/?type=usecase</a></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>web server: <a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a></li><li>diagram example: <a href="https://real-world-plantuml.com/">https://real-world-plantuml.com/</a></li><li>introduce: <a href="https://plantuml.com/zh/">https://plantuml.com/zh/</a></li><li>C4 model: <a href="https://github.com/plantuml-stdlib/C4-PlantUML">https://github.com/plantuml-stdlib/C4-PlantUML</a></li><li>install: <a href="https://formulae.brew.sh/formula/plantuml">https://formulae.brew.sh/formula/plantuml</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PlantUML </tag>
            
            <tag> C4 modal </tag>
            
            <tag> 绘图工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoCD Get Started</title>
      <link href="2021/01/16/gocd-get-started/"/>
      <url>2021/01/16/gocd-get-started/</url>
      
        <content type="html"><![CDATA[<h1 id="GoCD萌新入门之路"><a href="#GoCD萌新入门之路" class="headerlink" title="GoCD萌新入门之路"></a>GoCD萌新入门之路</h1><blockquote><p>因本文首次发布在牛客网，故而部分图片外链无法显示。可直接通过下方链接跳转牛客网查看。<br>Refer：<a href="https://blog.nowcoder.net/n/b800102df5354174b17819da225c4445">https://blog.nowcoder.net/n/b800102df5354174b17819da225c4445</a></p></blockquote><hr> <h2 id="一、啊，什么是GoCD呀"><a href="#一、啊，什么是GoCD呀" class="headerlink" title="一、啊，什么是GoCD呀"></a>一、啊，什么是GoCD呀</h2><p>首先，需要了解一下传统的集成方式，在传统的集成方式中，团队中每天上班拉取代码，下班前merge代码。若出现code conflict，大概率是大面积的code冲突，解决冲突便会花费超多时间，并且在传统方式中若不采取CI工具，也不能保证每次代码的提交的功能都是完整且不影响原有功能，一旦出现构建失败，不能及时发现也是其存在的问题。因此传统的集成方式存在很大的缺陷。</p><p>CI/CD就此出世。持续集成使用自动化工具协助开发团队，在每次merge代码后，尽可能无缝式的构建和测试代码。其主要流程包括：</p><ul><li>小步提交功能代码</li><li>代码必须配备单元测试</li><li>每次提交会自动触发CI server, 其开始执行Build -&gt; Test -&gt; Package -&gt; Deploy Dev Env任务</li><li>无论任务成功与否，都能及时给予团队反馈</li></ul><p>持续交付是基于持续集成实现的，其流水线的各步骤和代码的部署集成都是自动的，只是在需要发布产品时候手动发布即可。在整个CD过程中还包含了monitoring, alarm, log and other tools组成实现反馈闭环系统以保证发布产品的可靠性。</p><p>持续部署与持续交付的区别仅在于，持续部署在不同环境下对产品的发布都是自动的，也就是在提交代码后，若不存在问题，其会自动发布生产版本。其目的就在于使用此方式，在任何时候，代码都是可直接发布至生产阶段的。</p><p><strong>GoCD</strong>-一个开源的持续集成和持续交付（CI/CD）系统。</p><p>CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。没必要纠结其具体语义概念，CI/CD就是一个流程，用于实现应用开发中的高度持续自动化和持续监控。</p><h3 id="1、Pipeline、Stage、Job、Task"><a href="#1、Pipeline、Stage、Job、Task" class="headerlink" title="1、Pipeline、Stage、Job、Task"></a>1、Pipeline、Stage、Job、Task</h3><p>Pipeline、Stage、Job、Task依次为组合关系。一个Pipeline由多个Stage组成，Stage由Job组成，Job由Task组成。</p><p>1004 </p><ul><li>Task：是Pipeline中最小单位。需要执行的操作，通常是一个指令。eg: ./build</li><li>Job: 由一系列<strong>有序</strong>task组成。一般，若某task失败，Job也将停止（除非有指定）。其中的Task对environment variable的操作不会影响其他Task，但对文件系统的操作会影响其他tasks。</li><li>Stage: 由一系列<strong>并行</strong>的Job组成。其内的Jobs各自独立，可以并行执行。若某个Job失败，其他Jobs依然会继续运行，但当前Stage会被认为失败。</li><li>Pipeline: 由一系列<strong>有序</strong>Stage组成，若某个Stage失败，Pipeline则失败，其后所有Stage都不会Start。</li></ul><h3 id="2、Materials-and-triggers-何时Pipeline会开始运行？"><a href="#2、Materials-and-triggers-何时Pipeline会开始运行？" class="headerlink" title="2、Materials and triggers (何时Pipeline会开始运行？)"></a>2、Materials and triggers (何时Pipeline会开始运行？)</h3><p>Material 是Pipeline运行的一个基础。其通常是源代码材料仓（git,svn,mercurial,etc.），也可以是other Pipeline的Stage。</p><ul><li><p>GoCD Server 会不断的轮询Pipeline配置的Materials。当发现Materials有新的改变或提交时，Pipeline就会运行或被触发。</p></li><li><p>“time trigger” 是一种特殊Material，可以在指定的时间或指定时间间隔触发Pipeline。</p></li><li><p>Pipeline可以配置多个Materials，当任一Material有变化或提交都会触发Pipeline。</p></li></ul><p>1785</p><p><strong>Pipeline 作为 Material</strong></p><p>当Pipeline的一个Stage被用为另一个Pipeline的Material时，Material作用才更加突出。</p><p>如图：FirstPipeline的STAHE2时SecondPipeline的Material，当FirstPipeline的STAHE2执行完成后，即触发SecondPipeline开始运行。</p><p>FirstPipeline则称为Upstream Pipeline。</p><p>SecondPipeline称为DownStream Pipeline。</p><p>FirstPipeline的STAHE2被称为SecondPipeline的上游依赖。</p><p>2200 </p><p>Pipeline的任何Stage都可以作为Material，Stage运行完成即可触发新的Pipeline，不在乎其所在的Pipeline中后面的Stage是否成功。</p><h3 id="3、Fan-out-and-Fan-in-扇出和扇入"><a href="#3、Fan-out-and-Fan-in-扇出和扇入" class="headerlink" title="3、Fan-out and Fan-in (扇出和扇入)"></a>3、Fan-out and Fan-in (扇出和扇入)</h3><p>Fan-out 和 Fan-in是一个执行动作。</p><p>Fan-out: 当Material的完成，造成多个Downstream Pipeline被触发。该Material被称作Fan-out至Downstream Pipeline。即，由材料完成后，发散至多个下游Pipeline（1-&gt;多）。Fan-out的原因不一定总与Pipeline系系相关，可以是任何Material。</p><p>Fan-in: 指需要多种Upstream material 去触发Downstream Pipeline(多-&gt;1)。在GoCD中，其最重要一点在于必须在触发下游Pipeline前保证上游所有的material的版本一致。</p><p>2747</p><p>如上图所示，一个git仓作为Pipeline1和Pipeline2的material，此可称为Fan-out。而Pipeline1的Stage2和Pipeline2的Stage1可作为Pipeline3的material，此为Fan-in，若Pipeline1的Stage2慢于Pipeline2的Stage1，则Pipeline3会等待Pipeline Stage2的完成。多material情况下，必须保证每个material的版本是一致的，否则不会构建。</p><h3 id="4、Value-Stream-Map（VSM：价值流图）"><a href="#4、Value-Stream-Map（VSM：价值流图）" class="headerlink" title="4、Value Stream Map（VSM：价值流图）"></a>4、Value Stream Map（VSM：价值流图）</h3><p>VSM：是整个Pipeline的上游依存关系和触发的下游Pipeline的端到端视图。在决定触发哪些Pipeline时，GoCD的Fan-out和Fan-in方法将处理所有的依赖关系。</p><p>3206 </p><p>VSM，可以抽象的展示整个Pipeline的完整过程，从构建到生产。这是建模的抽象级别，可以直接展示端到端的工作流。其中也展示了一次构建Artifact并通过管道传播。并且在此图中展示了并行化的工作流程。正因为其展示了整个Pipeline，所以其可以提供提交到生产的审核性和可追溯性。</p><h3 id="5、Artifacts（Pipeline内或之间有文件传递怎么办？）"><a href="#5、Artifacts（Pipeline内或之间有文件传递怎么办？）" class="headerlink" title="5、Artifacts（Pipeline内或之间有文件传递怎么办？）"></a>5、Artifacts（Pipeline内或之间有文件传递怎么办？）</h3><p>GoCD中的每个Job都可以发布Artifacts。Artifacts可以使文件或者文件夹。</p><p>Job运行后，GoCD会确保Job指定的Artifact被发布并可被用户或者下游stage和pipeline使用。</p><p>一个Job可以发布多个Artifact。</p><p>类型：</p><p>Build Artifact：用于安装的程序，二进制文件，文档等。</p><p>Test Artifact：GoCD会尝试将文件解析为测试报告。</p><p><strong>如何获取Artifact</strong></p><p>GoCD提供一个指定任务“<strong>Fetch Artifact Task</strong>”，用于从任意祖先Pipeline（当前Pipeline的上流即可）获取和使用Artifact。GoCD会确保获取的Artifact版本是正确的。</p><p>3846</p><p>如图所示，Pipeline1发布了很多Artifacts，在Pipeline1/Stage2/Job1中的<strong>Fetch Artifact Task</strong>获取了其Stage1发布的文件。</p><p>在Pipeline2中获取了Pipeline1/Stage2/Job1发布的文件。Pipeline3中获取了Pipeline1/Stage1/Job2发布的文件夹（祖先-&gt;孙）。</p><h3 id="6、Go-Agent（Pipeline在哪里运行呢？）"><a href="#6、Go-Agent（Pipeline在哪里运行呢？）" class="headerlink" title="6、Go-Agent（Pipeline在哪里运行呢？）"></a>6、Go-Agent（Pipeline在哪里运行呢？）</h3><p>Go-Agent是GoCD生态系统的Workers。一个系统可以配置多个Go-Agent，但只有一个Go-Server。</p><p>Go-Server  : 是控制一切的服务器，提供用户界面，轮询Material是否有更改，分配相应的作业到各个Agent。其不会运行任何命令和进行部署。</p><p>Go-Agent : 执行具体工作的实施者，其执行由系统用户或管理员分配的任何工作。</p><p>当Job分配至Agent时，Agent会执行Job内的Task，并传递Job状态给Go-Server。因为Job可并行运行，所以其可分配至不同的Go-Agent，Go-Server会收集所有不同Job的状态信息，然后确定Stage状态。</p><h3 id="7、Resources（增强Agent和Jobs）"><a href="#7、Resources（增强Agent和Jobs）" class="headerlink" title="7、Resources（增强Agent和Jobs）"></a>7、Resources（增强Agent和Jobs）</h3><p>使用Resources可以增强Agent和Jobs。Resources是自由格式的标签，用于帮助Agent决定哪些Agent可以执行特定的Job。</p><ul><li>Resources由管理员自定义的，可以表示任何含义。其就是一个自定义标签，用于设定Agent和Job关系。</li><li>对Job分配Resources十分有用。若Job分配了Resource，则在Agent中就必须包含此Resource，这样才可成功运行此Job。</li><li>不需要Resource的Job，可以在任何Agent上被成功执行；但分配了Resource的Job，必须在包含此Resource的Agent才能成功执行。</li></ul><img src="https://docs.gocd.org/current/images/concepts/19_agents_jobs_resources.png" alt="19_agents_jobs_resources" style="zoom:25%;" /><p>假设：</p><p>Job1 需要 Firefox Resource，Job2 需要 Linux Resource，Job3 需要Firefox和Linux Resource，Job4 不需要Resource。</p><p>Agent1 具有 Firefox和Linux Resource，Agent2 没有 Resource，Agent3 具有Firefox和Apple Resource。</p><p>因此：</p><ol><li>Job1 只能分给带有Firefox Resource的Agent1或Agent3</li><li>Job2 只能分给Agent1</li><li>Job3 只能分给Agent1</li><li>Job4 可以给任一Agent</li></ol><p>Agent 3具有Apple Resource这一事实并不会阻止其被分配作业。即使其是未被使用的Resource。</p><h3 id="8、Environments（用于组合Pipeline和Agent的标签）"><a href="#8、Environments（用于组合Pipeline和Agent的标签）" class="headerlink" title="8、Environments（用于组合Pipeline和Agent的标签）"></a>8、Environments（用于组合Pipeline和Agent的标签）</h3><p>Environments 是GoCD中一种对Pipeline和Agent进行关联的方式。其规则：</p><ul><li>一个Pipeline最多只能关联一个Environments （0-1）</li><li>一个Agent可以与多个Environments关联，也可以与任何Environments都不关联 （0-n）</li><li>Agent只会被分配在同一Environments的Pipeline的Job</li><li>与任何Environments都不关联的Agent，只能执行与任何Environments都不关联的Pipeline。</li></ul><img src="https://docs.gocd.org/current/images/concepts/22_environment.png" alt="22_environment" style="zoom:28%;" /><p>如图：</p><ol><li>Pipeline1 ，2的Job只能由Agent1，2，3执行。</li><li>Pipeline3，4的Job只能由Agent3，4执行。</li><li>Pipeline5，6的Job只能由Agent5执行。</li></ol><p>Environments和Resources可以同时在Agent和Pipeline(Environments)/Job(Resources)匹配。</p><h3 id="9、Environment-Variables-（用于Task使用）"><a href="#9、Environment-Variables-（用于Task使用）" class="headerlink" title="9、Environment Variables （用于Task使用）"></a>9、Environment Variables （用于Task使用）</h3><p>Environment Variables 与 Environments 没有直接关系。</p><ul><li>环境变量是在配置中自定义的变量。其用于Task，与操作系统运行中使用的环境变量类似。</li><li>环境变量可以被定义多个层级，由外至内为：Environments-&gt;Pipeline-&gt;Stage-&gt;Job。</li><li>遵循级联系统，外层定义的若在内层也定义了，则会被内层变量值覆盖。若外层定义，而内层未定义，则会传递至内层Job。</li></ul><img src="https://docs.gocd.org/current/images/concepts/23_env_vars.png" alt="23_env_vars" style="zoom:28%;" /><p>如图，在Jon中各环境变量值分别为：</p><p>ENV_ENV = 1</p><p>ENV_PIP = 2</p><p>ENV_STG = 3</p><p>ENV_JOB = 4</p><p>MY_VAR = 4</p><h3 id="10、-Templates（可重用的工作流）"><a href="#10、-Templates（可重用的工作流）" class="headerlink" title="10、 Templates（可重用的工作流）"></a>10、 Templates（可重用的工作流）</h3><p>Templates 用于创建可重用的工作流，其目的在于：简化创建和维护分支以及管理大量Pipelines等任务。在Admin菜单的Template可以管理Pipeline Templates。</p><h2 id="二、来来来，创建一个属于自己的Pipeline"><a href="#二、来来来，创建一个属于自己的Pipeline" class="headerlink" title="二、来来来，创建一个属于自己的Pipeline"></a>二、来来来，创建一个属于自己的Pipeline</h2><p>万事开头难，若要使用GoCD，必须要先拥有它。若要GoCD正常工作，必须要有Go-Server和至少一个Go-Agent。</p><h3 id="1、Docker启动Go-Server和Go-Agent"><a href="#1、Docker启动Go-Server和Go-Agent" class="headerlink" title="1、Docker启动Go-Server和Go-Agent"></a>1、Docker启动Go-Server和Go-Agent</h3><ul><li>拉取go-serverv20.1.0 镜像： <code>docker pull gocd/gocd-server:v20.1.0</code></li><li>启动go-server: <code>docker run -d --name=&quot;go-server-v20.1.0&quot; -p 8153:8153 -v &lt;root-path&gt;/docker/go-server/godata:/godata gocd/gocd-server:v20.1.0</code></li><li>拉取go-serverv20.1.0 镜像： <code>docker pull gocd/gocd-agent-ubuntu-16.04:v20.1.0</code></li><li>启动Go-agent: 前提是go-server也在docker容器内运行，则可以使用：<code>docker run -d -e GO_SERVER_URL=http://$(docker inspect --format=&#39;&#123;&#123;(index (index.NetworkSettings.IPAddress))&#125;&#125;&#39; go-server-v20.1.0):8153/go gocd/gocd-agent-ubuntu-16.04:v20.1.0</code></li></ul><h3 id="2、创建Pipeline"><a href="#2、创建Pipeline" class="headerlink" title="2、创建Pipeline"></a>2、创建Pipeline</h3><ol><li>本地运行后，浏览器打开localhost:8153进入主页；若在服务器运行，也是对应服务器IP的8153端口。</li><li>选择Materials类型Git，输入git仓地址（示例的demo的git仓http地址,若pipeline的Material为另一个pipeline，则更换类型进行选择即可）。输入定义的Pipeline名字，Stage名字，并定义一个Job：执行./build脚本。</li></ol><p>7314 </p><ol start="3"><li>点击Save+Run this Pipeline，会进行跳转，并运行此Pipeline。</li></ol><p>7488 </p><ol start="4"><li>待运行成功后，进度会变成绿色。点击小齿轮，可进入设置页面。</li></ol><p>7646 </p><p>在其中就可以设置Resources，Environment variable，Artifacts。也可以在Pipeline设置中增加Stage，在Stage设置中增加Job，在Job设置中增加Tasks。</p><p>更多有关GoCD细节操作可查看官方文档~<br><strong>reference:</strong> <a href="https://docs.gocd.org/current/">https://docs.gocd.org/current/</a></p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoCD </tag>
            
            <tag> CI/CD </tag>
            
            <tag> Pipeline </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Quick Start</title>
      <link href="2021/01/01/hello-world/"/>
      <url>2021/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Help </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
